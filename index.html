<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forte Card Previewer</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Pirata+One&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="assets/css/theme.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    </head>
<body class="font-sans"> <div id="page-loading-overlay" class="page-loading-overlay">
        <div class="loader-container">
            <div class="loader"></div>
            <div id="loading-text" class="loader-text">Loading Forte Card Previewer...</div>
        </div>
    </div>

    <div id="threejs-bg"></div>

    <div class="container mx-auto max-w-7xl rounded-lg shadow-lg p-4 md:p-6"> <div class="header-container">
            <div class="brand-area">
                <div class="logo-container">
                    <img src="resources/forte-arrivals.png" alt="Forte Logo" class="forte-logo" onerror="this.style.display='none';" loading="lazy">
                </div>
                <h1 class="title-glow font-pirata">Card Previewer</h1> </div>
            <div class="controls-area">
                <div class="filter-size-row">
                    <div id="filter-controls" class="flex flex-wrap items-center gap-y-2 gap-x-4">
                        <h2 class="controls-label hidden md:block">Filters:</h2>
                        <div>
                            <label for="type-filter" class="filter-label">Type:</label>
                            <select id="type-filter" name="type-filter" class="filter-select">
                                <option value="all">All Types</option>
                            </select>
                        </div>
                        <div>
                            <label for="forte-filter" class="filter-label">Forte:</label>
                            <select id="forte-filter" name="forte-filter" class="filter-select">
                                <option value="all">All</option>
                                <option value="yes">Forte Only</option>
                                <option value="no">Non-Forte</option>
                            </select>
                        </div>
                        <div>
                            <label for="trainer-type-filter" class="filter-label">Trainer:</label>
                            <select id="trainer-type-filter" name="trainer-type-filter" class="filter-select">
                                <option value="all">All Trainers</option>
                            </select>
                        </div>
                        <div>
                            <label for="creator-filter" class="filter-label">Creator:</label>
                            <select id="creator-filter" name="creator-filter" class="filter-select">
                                <option value="all">All Creators</option>
                            </select>
                        </div>
                    </div> <div id="access-controls" class="flex items-center gap-x-3 ml-auto pl-4"> <button id="unlock-button" class="access-button" title="Unlock Full Version">
                            <i id="unlock-icon" class="fas fa-lock"></i> </button>
                    </div>
                    <div id="size-controls" class="flex flex-wrap items-center gap-y-2 gap-x-4" style="display: none;">
                       </div>
    
               </div> <div id="tab-container" class="flex flex-wrap gap-x-2 gap-y-2 items-center justify-end w-full">
                   </div>
            </div>
                   <div id="size-controls" class="flex flex-wrap items-center gap-y-2 gap-x-4" style="display: none;">
                       <h2 class="controls-label hidden md:block">Sizes:</h2>
                       <div class="size-control-group">
                           <label for="gallery-size-slider" class="size-label">Gallery:</label>
                           <input type="range" id="gallery-size-slider" name="gallery-size" min="0" max="2" step="1" value="1" class="size-slider">
                           <span id="gallery-size-display" class="size-display">M</span>
                       </div>
                   </div>
                </div>
                <div id="tab-container" class="flex flex-wrap gap-x-2 gap-y-2 items-center justify-end w-full">
                    <h2 class="controls-label hidden md:block">Set:</h2>
                    </div>
            </div>
        </div>

        <div class="gallery-section border-t border-[var(--color-border)] pt-4 mt-4"> <div id="item-gallery" class="grid gap-4 items-start" role="grid"> </div>
            <p id="empty-folder-message" class="text-center mt-4 hidden">No images match the current filters.</p>
        </div>

        <footer class="footer">
            <img src="resources/tcg-pocket-logo.png" alt="TCG Pocket Logo" onerror="this.style.display='none';" loading="lazy">
            <span>Fan Project - Testing Previewer</span>
            <img src="resources/tcg-pocket-logo.png" alt="TCG Pocket Logo" onerror="this.style.display='none';" loading="lazy">
       </footer>

    </div> <div id="fancy-lightbox" class="fancy-lightbox-overlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="fancy-lightbox-content">
            <div class="fancy-lightbox-header">
                <h2 class="fancy-lightbox-title">
                    <i class="fas fa-crown mr-2 text-[var(--color-accent)]"></i>
                    <span id="card-title">Forte Card Viewer</span>
                </h2>
                <button id="fancy-lightbox-close" class="fancy-lightbox-close" aria-label="Close card viewer">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="fancy-lightbox-body">
                <div class="fancy-card-info">
                    <div class="info-section">
                         <div class="info-section-title"><i class="fas fa-id-card text-[var(--color-accent)]"></i><span>Card Details</span></div>
                         <div class="info-item"><div class="info-label">Card Name</div><div id="info-card-name" class="info-value">-</div></div>
                         <div class="info-item"><div class="info-label">Set</div><div id="info-set-name" class="info-value">-</div></div>
                         <div class="info-item"><div class="info-label">Number</div><div id="info-card-number" class="info-value">-</div></div>
                           <div class="info-item"><div class="info-label">Dex Number</div><div id="info-dex-number" class="info-value">-</div></div>
                     </div>
                     <div class="info-section">
                         <div class="info-section-title"><i class="fas fa-tag text-[var(--color-accent)]"></i><span>Classification</span></div>
                         <div class="info-item"><div class="info-label">Card Type</div><div id="info-card-type" class="info-value">-</div><div id="info-type-badges" class="card-types"></div></div>
                         <div class="info-item"><div class="info-label">Forte Status</div><div id="info-forte-status" class="info-value">-</div></div>
                         <div id="info-trainer-type-container" class="info-item" style="display: none;"><div class="info-label">Trainer Type</div><div id="info-trainer-type" class="info-value">-</div></div>
                     </div>
                     <div class="info-section">
                         <div class="info-section-title"><i class="fas fa-user-edit text-[var(--color-accent)]"></i><span>Creation & Popularity</span></div>
                         <div class="info-item"><div class="info-label">Creator</div><div id="info-creator" class="info-value">-</div></div>
                         <div class="info-item"><div class="info-label">File Name</div><div id="info-file-name" class="info-value text-xs break-all opacity-50">-</div></div>
                         <div class="info-item"><div class="info-label">Likes</div><div class="info-value flex items-center"><span id="lb-like-count" class="mr-2">0</span><button id="lb-like-button" class="like-button" aria-label="Like this card"><i class="far fa-heart"></i></button></div></div>
                     </div>
                </div>
                <div class="fancy-card-display">
                    <div id="fancy-spinner" class="spinner hidden"></div>
                    <div id="fancy-holo-container" class="fancy-holo-container">
                        <div id="fancy-holo-inner" class="fancy-holo-inner">
                            <img id="fancy-card-image" class="fancy-card-image hidden" src="" alt="Card preview" loading="lazy">
                        </div>
                    </div>
                    <div id="fancy-card-controls" class="fancy-card-controls">
                        <button id="fancy-normal-view" class="fancy-control-button active" data-view="normal"><i class="fas fa-image"></i><span>Normal</span></button>
                        <button id="fancy-textless-view" class="fancy-control-button" data-view="textless" disabled><i class="fas fa-square"></i><span>Textless</span></button>
                    </div>
                    <div class="fancy-nav-controls">
                        <button id="fancy-prev-button" class="fancy-nav-button" aria-label="Previous card"><i class="fas fa-chevron-left"></i></button>
                        <button id="fancy-next-button" class="fancy-nav-button" aria-label="Next card"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    <div class="fancy-zoom-controls">
                        <button id="fancy-zoom-in" class="fancy-zoom-button" aria-label="Zoom in"><i class="fas fa-search-plus"></i></button>
                        <button id="fancy-zoom-reset" class="fancy-zoom-button" aria-label="Reset zoom"><i class="fas fa-expand"></i></button>
                        <button id="fancy-zoom-out" class="fancy-zoom-button" aria-label="Zoom out"><i class="fas fa-search-minus"></i></button>
                    </div>
                    <div class="keyboard-hint">
                        <span><kbd>←</kbd> <kbd>→</kbd> Navigate</span>
                        <span><kbd>+</kbd> <kbd>-</kbd> <kbd>0</kbd> Zoom</span>
                        <span><kbd>Esc</kbd> Close</span>
                        <span><kbd>Space</kbd> Toggle View</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="audio-prompt" style="display: block;">Click anywhere to enable audio</div>
    <div id="audio-control-container" style="display: none;">
         <span id="song-name"></span>
         <button id="play-pause-button" class="audio-button" aria-label="Play/Pause"><i class="fas fa-play"></i></button>
         <button id="next-song-button" class="audio-button" aria-label="Next Song"><i class="fas fa-forward-step"></i></button>
         <div id="mute-button" class="audio-button relative" aria-label="Mute/Unmute">
             <i class="fas fa-volume-high"></i>
             <div id="volume-container" class="absolute bottom-full mb-2 left-1/2 transform -translate-x-1/2 p-2 bg-[rgba(30,41,59,0.9)] rounded hidden"> <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.2" class="volume-slider-style">
             </div>
         </div>
    </div>

    <script src="image_data.js"></script>
     <script src="js/background.js"></script> 
     <script src="db-likes.js"></script>   
     <script src="js/audio.js"></script>
     <script>
        // --- Configuration ---
        const placeholderUrl = "https://placehold.co/100x80/cccccc/ffffff.png?text=Error";
        const mainPlaceholderUrl = "https://placehold.co/600x400/cccccc/ffffff.png?text=Loading...";
        const CLICK_EFFECT_DURATION_MS = 400;
        const HOVER_EFFECT_TIMEOUT_MS = 1000;
        const RESOURCE_FOLDER = 'resources';
        const BLANK_SUFFIX = '-BL-';
        const SIZE_MAP = ['S', 'M', 'L'];
        const GALLERY_SIZE_CLASSES = { 0: 'gallery-size-s', 1: 'gallery-size-m', 2: 'gallery-size-l' };
        const DEFAULT_GALLERY_SIZE_INDEX = 1;
        const GALLERY_SIZE_KEY = 'galleryImageSizePref';
        const PRELOAD_NEXT_PREV = true;
        const INITIAL_PRELOAD_COUNT = 24;
        // --- Preview Mode Config ---
        const PREVIEW_PASSWORD = "forte"; // *** CHANGE THIS PASSWORD ***
        const PREVIEW_STORAGE_KEY = 'fortePreviewUnlocked'; // localStorage key
        const ALLOWED_PROMOS_PREVIEW = ["001", "002"]; // Set numbers of promos allowed
        const UNBOUND_SET_NAME = "Other"; // Internal setName for Unbound cards (check your config)
        const PROMO_SET_NAME = "Promo"; // Internal setName for Promo cards
    
        // --- Elements ---
        const pageLoadingOverlay = document.getElementById('page-loading-overlay');
        const loadingTextElement = document.getElementById('loading-text');
        const itemGallery = document.getElementById('item-gallery');
        const tabContainer = document.getElementById('tab-container');
        const typeFilterSelect = document.getElementById('type-filter');
        const forteFilterSelect = document.getElementById('forte-filter');
        const trainerTypeFilterSelect = document.getElementById('trainer-type-filter');
        const creatorFilterSelect = document.getElementById('creator-filter');
        const emptyFolderMessage = document.getElementById('empty-folder-message');
        const gallerySizeSlider = document.getElementById('gallery-size-slider');
        const gallerySizeDisplay = document.getElementById('gallery-size-display');
        const unlockButton = document.getElementById('unlock-button'); // New element
        const unlockIcon = document.getElementById('unlock-icon');     // New element
        // ... (Keep all other element references: Lightbox, Card Info, etc.) ...
        const fancyLightbox = document.getElementById('fancy-lightbox');
        const fancyLightboxContent = fancyLightbox.querySelector('.fancy-lightbox-content');
        const fancyLightboxClose = document.getElementById('fancy-lightbox-close');
        const fancyCardTitle = document.getElementById('card-title');
        const fancySpinner = document.getElementById('fancy-spinner');
        const fancyHoloContainer = document.getElementById('fancy-holo-container');
        const fancyHoloInner = document.getElementById('fancy-holo-inner');
        const fancyCardImage = document.getElementById('fancy-card-image');
        const fancyPrevButton = document.getElementById('fancy-prev-button');
        const fancyNextButton = document.getElementById('fancy-next-button');
        const fancyNormalView = document.getElementById('fancy-normal-view');
        const fancyTextlessView = document.getElementById('fancy-textless-view');
        const fancyZoomIn = document.getElementById('fancy-zoom-in');
        const fancyZoomOut = document.getElementById('fancy-zoom-out');
        const fancyZoomReset = document.getElementById('fancy-zoom-reset');
        const infoCardName = document.getElementById('info-card-name');
        const infoSetName = document.getElementById('info-set-name');
        const infoCardNumber = document.getElementById('info-card-number');
        const infoDexNumber = document.getElementById('info-dex-number');
        const infoCardType = document.getElementById('info-card-type');
        const infoTypeBadges = document.getElementById('info-type-badges');
        const infoForteStatus = document.getElementById('info-forte-status');
        const infoTrainerTypeContainer = document.getElementById('info-trainer-type-container');
        const infoTrainerType = document.getElementById('info-trainer-type');
        const infoCreator = document.getElementById('info-creator');
        const infoFileName = document.getElementById('info-file-name');
        const lbLikeButton = document.getElementById('lb-like-button');
        const lbLikeCount = document.getElementById('lb-like-count');
    
        // --- State ---
        let isPreviewMode = true; // Start locked by default
        let currentSetTab = 'all';
        let currentImageFiles = []; // For lightbox nav
        let currentImageIndex = -1;
        let focusableElements = [];
        let currentFocusIndex = 0;
        let currentlyDisplayedImages = []; // Full list matching user filters *and* preview mode
        let currentTypeFilter = 'all';
        let currentForteFilter = 'all';
        let currentTrainerTypeFilter = 'all';
        let currentCreatorFilter = 'all';
        let baseImageSet = []; // Images for current tab AFTER preview filtering
        let currentGallerySizeIndex = DEFAULT_GALLERY_SIZE_INDEX;
        let lastScrollY = 0;
        let allCreators = new Set();
        let currentFancyCardImage = null;
        let fancyHasBlankVersion = false;
        let fancyBlankVersionPath = '';
        let fancyNormalVersionPath = '';
        let fancyActiveHoloTimeout = null;
        let isZoomed = false;
        let imageCache = new Map(); // Session Cache
        let intersectionObserver; // Lazy Loader
        let backgroundAnimationPaused = false;
        let hoverEffectTimeouts = new Map();
    
        // --- Data loaded from image_data.js ---
        let rootImageStructure = null;
        let filterConfig = null;
        let allImagesMasterList = []; // Store the full list of all images once loaded
    
        // ===============================================
        // === IMAGE PRELOADING & CACHING LOGIC ========
        // ===============================================
        // (Keep the preloadImage, preloadInitialImages, preloadAdjacentLightboxImages, preloadAdjacentGalleryImages functions here)
        function preloadImage(encodedSrc) {
            if (!encodedSrc) return Promise.reject(new Error("Invalid src"));
            if (imageCache.has(encodedSrc)) {
                const cached = imageCache.get(encodedSrc);
                return (cached instanceof HTMLImageElement) ? Promise.resolve(cached) : cached;
            }
            const loadPromise = new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => { imageCache.set(encodedSrc, img); resolve(img); };
                img.onerror = () => { imageCache.delete(encodedSrc); console.warn(`[Cache] Failed load: ${encodedSrc}`); reject(new Error(`Failed load: ${encodedSrc}`)); };
                img.src = encodedSrc;
            });
            imageCache.set(encodedSrc, loadPromise);
            return loadPromise;
        }
        async function preloadInitialImages(count) {
            console.log(`[Preload] Starting initial preload for up to ${count} gallery images.`);
            // Use baseImageSet which is already filtered for preview mode if active
            if (!baseImageSet) return;
            const nonBlankImages = baseImageSet.filter(img => !img.isBlank); // Preload non-blanks from current view
            const imagesToPreload = nonBlankImages.slice(0, count);
            const preloadPromises = [];
            const totalToLoad = imagesToPreload.length;
            if (totalToLoad === 0) { console.log("[Preload] No initial images to preload."); return; }
            loadingTextElement.textContent = `Preloading images... (0/${totalToLoad})`;
            for (let i = 0; i < totalToLoad; i++) {
                const image = imagesToPreload[i];
                const encodedPath = encodeImagePath(image.path);
                if (encodedPath) {
                    if (loadingTextElement && i > 0) { loadingTextElement.textContent = `Preloading images... (${i}/${totalToLoad})`; }
                    preloadPromises.push(preloadImage(encodedPath).catch(err => { /* ignore */ }));
                }
            }
            await Promise.allSettled(preloadPromises);
            console.log(`[Preload] Finished initial batch of ${totalToLoad} images.`);
            if (loadingTextElement) loadingTextElement.textContent = "Loading Forte Card Previewer...";
        }
        function preloadAdjacentLightboxImages() { /* ... function code ... */ }
        function preloadAdjacentGalleryImages(visibleThumbnail) { /* ... function code ... */ }
    
    
        // ===============================================
        // === UTILITY FUNCTIONS =========================
        // ===============================================
        function getExtension(filename = '') { /* ... function code ... */ }
        function encodeImagePath(path) { /* ... function code ... */ }
        function pauseBackgroundAnimation(pause) { /* ... function code ... */ }
        function hexToRgba(hex, alpha = 1) { /* ... function code ... */ }
        function lightenHexColor(hex, percent) { /* ... function code ... */ }
        function isElementInViewport(el) { /* ... function code ... */ }
        function ensurePageLoaded() { /* ... function code ... */ }
        function displayError(message) { /* ... function code ... */ }
    
        // ===============================================
        // === DATA HANDLING =============================
        // ===============================================
        /** Recursively finds all file objects and populates creators set */
        function getAllImageFilesRecursive(node) {
            // --- Keep this function definition here ---
            // It populates the global 'allCreators' set
            let files = [];
            if (!node?.children) return files;
            for (const child of node.children) {
                if (child.type === 'file') {
                    if (child.creator && !allCreators.has(child.creator)) {
                        allCreators.add(child.creator);
                    }
                    // Ensure isBlank is set during initial load if generator missed it
                    child.isBlank = child.isBlank ?? (child.name?.includes(BLANK_SUFFIX) ?? false);
                    files.push(child);
                } else if (child.type === 'folder') {
                    files = files.concat(getAllImageFilesRecursive(child));
                }
            }
            return files;
        }
    
    
        // ===============================================
        // === NEW: PREVIEW MODE / UNLOCK LOGIC =========
        // ===============================================
    
        /** Updates the unlock icon based on the isPreviewMode state */
        function updateUnlockIcon() {
            if (!unlockIcon || !unlockButton) return;
            if (isPreviewMode) {
                unlockIcon.classList.remove('fa-lock-open');
                unlockIcon.classList.add('fa-lock');
                unlockButton.title = "Unlock Full Version";
                unlockButton.classList.remove('unlocked');
            } else {
                unlockIcon.classList.remove('fa-lock');
                unlockIcon.classList.add('fa-lock-open');
                unlockButton.title = "Full Version Unlocked"; // Simple title
                unlockButton.classList.add('unlocked');
            }
        }
    
        /** Handles the click on the unlock button */
        function handleUnlockAttempt() {
            if (!isPreviewMode) {
                // Currently unlocked - Optionally implement re-locking here
                // For now, just inform the user or do nothing
                 alert("Full version is already unlocked.");
                // To re-lock:
                // isPreviewMode = true;
                // localStorage.removeItem(PREVIEW_STORAGE_KEY);
                // updateUnlockIcon();
                // renderTabs();
                // handleTabChange(currentSetTab); // Re-apply preview filter
                return;
            }
    
            // Prompt for password (replace with a modal for better UX)
            const enteredPassword = prompt("Enter password to unlock full version:");
    
            if (enteredPassword === null) return; // User cancelled
    
            if (enteredPassword === PREVIEW_PASSWORD) {
                // Correct password
                alert("Password correct! Unlocking full version."); // Replace alert
                isPreviewMode = false; // Set state to unlocked
                try {
                    localStorage.setItem(PREVIEW_STORAGE_KEY, "unlocked"); // Save state
                } catch (e) { console.error("Error saving unlock state:", e); }
                console.log("[Access] Unlocked Full Mode.");
                updateUnlockIcon(); // Update button icon
                renderTabs(); // Re-render tabs (removes "Coming Soon")
                // Re-filter and render the currently selected tab with full data
                handleTabChange(currentSetTab);
            } else {
                // Incorrect password
                alert("Incorrect password."); // Replace alert
            }
        }
    
        // ===============================================
        // === FILTERING AND TABS (Updated for Preview) ==
        // ===============================================
    
        /**
         * Applies USER filter state (Type, Forte, etc.) to the CURRENT baseImageSet
         * (which is already filtered by preview mode via handleTabChange),
         * determines gallery display list (prioritizing normal), and triggers rendering.
         */
        function applyFiltersAndRender() {
            console.log(`[Filter] Applying USER filters: Type='${currentTypeFilter}', Forte='${currentForteFilter}', etc.`);
            console.log(`[Filter] Current baseImageSet size (after potential preview filter): ${baseImageSet.length}`);
    
            // --- Step 1: Filter the CURRENT baseImageSet based on user filter controls ---
            let userFilteredImages = baseImageSet.filter(img => {
                const typeMatch = currentTypeFilter === 'all' || img.cardType === currentTypeFilter;
                const forteMatch = currentForteFilter === 'all' ||
                                   (currentForteFilter === 'yes' && img.isForte === true) ||
                                   (currentForteFilter === 'no' && img.isForte === false);
                const trainerMatch = currentTrainerTypeFilter === 'all' ||
                                   ((currentTypeFilter === 'all' || img.cardType === 'Trainer') && img.trainerType === currentTrainerTypeFilter);
                const creatorMatch = currentCreatorFilter === 'all' || img.creator === currentCreatorFilter;
                return typeMatch && forteMatch && trainerMatch && creatorMatch;
            });
            console.log(`[Filter] Found ${userFilteredImages.length} images matching user filters (incl. blanks).`);
    
            // Store this list (it reflects user filters *and* preview mode)
            currentlyDisplayedImages = userFilteredImages;
    
            // --- Step 2: Determine the final list to RENDER in the gallery grid ---
            // Prioritize normal over blank from the user-filtered list
            const imagesToRenderMap = new Map();
            for (const image of userFilteredImages) {
                const ext = getExtension(image.name);
                const isBlank = image.isBlank ?? (image.name?.includes(BLANK_SUFFIX) ?? false);
                const baseName = isBlank ? image.name.replace(BLANK_SUFFIX + ext, '') : image.name.replace(ext, '');
                const cardKey = `${image.setName || 'UnknownSet'}_${baseName}`;
                const existingEntry = imagesToRenderMap.get(cardKey);
                if (!existingEntry || (existingEntry.isBlank && !isBlank)) {
                    imagesToRenderMap.set(cardKey, { ...image, isBlank });
                }
            }
            const imagesToRenderInGallery = Array.from(imagesToRenderMap.values());
            console.log(`[Filter] Determined ${imagesToRenderInGallery.length} unique cards to render in gallery.`);
    
            // --- Step 3: Render the gallery ---
            renderGalleryView(imagesToRenderInGallery);
        }
    
        /** Populates filter dropdowns based on ALL available data */
        function populateFilters() {
            // This should use the full 'allCreators' list populated from the master list
            if (!filterConfig || !typeFilterSelect || !trainerTypeFilterSelect || !creatorFilterSelect) {
                console.error("[Populate Filters] Missing config or select elements."); return;
            }
            console.log("[Populate Filters] Populating dropdowns...");
            const clearOptions = (sel) => { while (sel.options.length > 1) sel.remove(1); };
            clearOptions(typeFilterSelect); filterConfig.typeOrder?.forEach(t => { if(t) typeFilterSelect.add(new Option(t, t)); });
            clearOptions(trainerTypeFilterSelect); filterConfig.trainerTypeOrder?.forEach(t => { if(t) trainerTypeFilterSelect.add(new Option(t, t)); });
            clearOptions(creatorFilterSelect);
            const sortedCreators = Array.from(allCreators).filter(Boolean).sort(); // Use global allCreators
            console.log(`[Populate Filters] Populating with ${sortedCreators.length} creators.`);
            sortedCreators.forEach(c => { creatorFilterSelect.add(new Option(c, c)); });
        }
    
        /** Renders the set navigation tabs, handling preview mode display */
        function renderTabs() {
            if (!tabContainer || !allImagesMasterList || !filterConfig?.setOrder || !filterConfig?.setColors) { // Check allImagesMasterList
                console.error("[Render Tabs] Missing elements, master list, or config."); return;
            }
            const label = tabContainer.querySelector('h2'); tabContainer.innerHTML = ''; if (label) tabContainer.appendChild(label);
    
            // Determine available sets from the MASTER list, not the filtered one
            const availableSetNames = new Set(allImagesMasterList.map(img => img.setName).filter(name => name && name !== "Misc"));
            console.log("[Render Tabs] Available set names:", Array.from(availableSetNames));
    
            const createTabButton = (setName, text) => {
                const button = document.createElement('button');
                button.className = 'tab';
                button.dataset.setName = setName;
    
                // --- Preview Mode Logic for Tabs ---
                let isComingSoon = false;
                const allowedPreviewSets = ['all', PROMO_SET_NAME, UNBOUND_SET_NAME]; // Internal names allowed
                if (isPreviewMode && !allowedPreviewSets.includes(setName)) {
                    isComingSoon = true;
                    text = "Coming Soon"; // Override display text
                    button.classList.add('tab-coming-soon'); // Add class for styling
                    button.disabled = true; // Disable the button
                }
                // --- End Preview Mode Logic ---
    
                const tabColor = filterConfig.setColors[setName] || filterConfig.setColors['default'] || '#6B7280';
                button.style.setProperty('--tab-active-border-color', tabColor);
                button.style.setProperty('--tab-active-bg-color', hexToRgba(tabColor, 0.3));
                const textSpan = document.createElement('span');
                textSpan.textContent = text; // Use potentially overridden text
    
                // --- Custom Text Color Logic ---
                if (setName === UNBOUND_SET_NAME) { // Special style for Unbound/Other
                    button.style.setProperty('--tab-active-text-color', '#A020F0'); // Example Purple
                } else if (isComingSoon) {
                    button.style.setProperty('--tab-active-text-color', '#9ca3af'); // Grey for active coming soon
                    textSpan.style.opacity = '0.6'; // Fade inactive text
                } else {
                    button.style.setProperty('--tab-active-text-color', lightenHexColor(tabColor, 0.8));
                }
                // --- End Custom Text Color ---
    
                button.appendChild(textSpan);
                return button;
            };
    
            // Create "All" tab (always enabled)
            const allTab = createTabButton('all', 'All');
            if (currentSetTab === 'all') allTab.classList.add('active'); // Set active if it's the current tab
            tabContainer.appendChild(allTab);
    
            // Create Tabs based on setOrder
            filterConfig.setOrder.forEach(setName => {
                // Create tab regardless of images, but handle "Coming Soon"
                if (setName !== 'all') { // 'all' tab already created
                    // Use the internal setName from setOrder to create the button
                    const setTab = createTabButton(setName, setName); // Use internal name as default text
                    if (currentSetTab === setName) setTab.classList.add('active'); // Set active if it's the current tab
                    tabContainer.appendChild(setTab);
                }
            });
    
            // Attach event listener (ensure only once)
            if (!tabContainer.dataset.listenerAttached) {
                tabContainer.addEventListener('click', (e) => {
                    const clickedTab = e.target.closest('.tab:not([disabled])'); // Only react if not disabled
                    if (clickedTab && !clickedTab.classList.contains('active')) {
                        const newSetName = clickedTab.dataset.setName;
                        tabContainer.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                        clickedTab.classList.add('active');
                        // Call handler to update state and trigger re-render
                        handleTabChange(newSetName);
                    }
                });
                tabContainer.dataset.listenerAttached = 'true';
            }
        }
    
        /**
         * Handles tab changes: Updates currentSetTab, filters the MASTER list based on preview mode,
         * sets the baseImageSet, and triggers applyFiltersAndRender.
         */
        function handleTabChange(newSetName) {
            console.log(`[Tab Change] Switching to tab: ${newSetName}`);
            currentSetTab = newSetName; // Update global state
    
            // 1. Get the correct subset from the MASTER list based on the tab clicked
            let setFilteredList;
            if (newSetName === 'all') {
                // 'All' tab shows everything except 'Misc'
                setFilteredList = allImagesMasterList.filter(img => img.setName !== "Misc");
            } else {
                // Specific set tab shows only images from that set
                setFilteredList = allImagesMasterList.filter(img => img.setName === newSetName);
            }
            console.log(`[Tab Change] Images in set '${newSetName}': ${setFilteredList.length}`);
    
            // 2. Apply PREVIEW MODE filtering if active
            if (isPreviewMode) {
                console.log("[Tab Change] Applying Preview Mode filter...");
                baseImageSet = setFilteredList.filter(img => {
                    // Always allow "Unbound" cards
                    if (img.setName === UNBOUND_SET_NAME) return true;
                    // Allow specific promos
                    if (img.setName === PROMO_SET_NAME && ALLOWED_PROMOS_PREVIEW.includes(img.setNumber)) return true;
                    // Allow cards if the *tab itself* is 'all' (we filter sets later based on tabs)
                    // This seems redundant now, as we filter by tab first. Let's remove this.
                    // if (currentSetTab === 'all' && (img.setName === UNBOUND_SET_NAME || (img.setName === PROMO_SET_NAME && ALLOWED_PROMOS_PREVIEW.includes(img.setNumber)))) return true;
    
                    // If not Unbound or allowed Promo, exclude in preview mode
                    return false;
                });
                console.log(`[Tab Change] Images after Preview Mode filter: ${baseImageSet.length}`);
            } else {
                // Full access mode: baseImageSet is just the list filtered by the tab
                baseImageSet = setFilteredList;
                console.log(`[Tab Change] Full Access Mode - baseImageSet size: ${baseImageSet.length}`);
            }
    
            // 3. Trigger user filter application and gallery rendering
            applyFiltersAndRender();
        }
    
    
        

        // ===============================================
        // === LIGHTBOX LOGIC ============================
        // ===============================================

        /** Opens the Fancy Lightbox with the selected image object */
        function openFancyLightbox(imageObject) {
            if (!imageObject || typeof imageObject !== 'object') {
                console.error("Invalid image object passed to openFancyLightbox:", imageObject);
                return;
            }
            console.log(`[Lightbox] Opening for: ${imageObject.path}`);

            lastScrollY = window.scrollY;
            currentFancyCardImage = imageObject; // Store the object being viewed

            // Determine navigation sequence based on currently *displayed* non-blank images
            currentImageFiles = currentlyDisplayedImages.filter(img => !img.isBlank);
            currentImageIndex = currentImageFiles.findIndex(img => img.path === imageObject.path);

            // Fallback logic if the clicked image isn't in the current filtered list
            if (currentImageIndex === -1) {
                console.warn("[Lightbox] Clicked image not found in current display list. Falling back to base set for navigation.");
                currentImageFiles = baseImageSet.filter(img => !img.isBlank); // Use base set for the tab
                currentImageIndex = currentImageFiles.findIndex(img => img.path === imageObject.path);
                // Final fallback: just the single image if still not found
                if (currentImageIndex === -1) {
                    console.warn("[Lightbox] Fallback failed. Showing only clicked image.");
                    currentImageFiles = [imageObject];
                    currentImageIndex = 0;
                }
            }

            // Update UI elements
            fancyCardTitle.textContent = imageObject.cardName || "Card Preview";
            updateCardInfo(imageObject); // Populate info panel
            checkBlankVersion(imageObject); // Determine if textless version exists, set paths/button state
            resetZoom(); // Ensure zoom is reset

            // Load the correct image version (normal or blank) based on the object property
            const imagePathToLoad = imageObject.isBlank ? fancyBlankVersionPath : fancyNormalVersionPath;
            loadFancyCardImage(imagePathToLoad); // Load the image (uses cache)

            preloadAdjacentLightboxImages(); // Start preloading next/prev for lightbox
            updateFancyNavigation(); // Update prev/next button states

            // Show lightbox & manage body scroll/focus
            fancyLightbox.classList.add('visible');
            fancyLightbox.setAttribute('aria-hidden', 'false');
            document.body.style.overflow = 'hidden';

            setTimeout(() => fancyLightboxClose.focus(), 100); // Focus close button for accessibility
            highlightThumbnail(imageObject.path); // Highlight corresponding gallery thumb
            applyFancyHoloListeners('#fancy-holo-container'); // Ensure holo effect listeners active
            pauseBackgroundAnimation(true); // Pause background if active
            updateLightboxLikeStatus(imageObject.path); // Update like button/count
        }

        /** Asynchronously loads the main image into the lightbox viewer, using the cache */
        async function loadFancyCardImage(path) {
            if (!path) { console.error("[Lightbox] No path provided to load."); return; }
            fancySpinner.classList.remove('hidden');
            fancyCardImage.classList.add('hidden'); // Hide while loading
            fancyHoloInner.classList.remove('holo-active'); // Reset holo state

            function encodeImagePath(path) {
        if (!path) return '';
        try {
            // Only replace '#' with '%23'. Keep spaces and other characters as is.
            // If other characters cause issues, add specific replacements here.
            // NOTE: This assumes your server/local setup can handle spaces in paths.
            return path.replace(/#/g, '%23');
        } catch (e) {
            console.error("Error encoding path:", path, e);
            return path; // Fallback to original path on error
        }
    }

        /** Updates the information panel in the lightbox */
        function updateCardInfo(card) {
            if (!card) return; // Safety check

            // Helper function to safely set text content or default
            const setText = (element, value, defaultValue = '-') => {
                if (element) element.textContent = value || defaultValue;
            };

            setText(infoCardName, card.cardName, 'Unknown Name');
            setText(infoSetName, card.setName, 'Unknown Set');
            setText(infoCardNumber, card.setNumber);
            setText(infoDexNumber, card.dexNumber);
            setText(infoCardType, card.cardType, 'Unknown Type');
            setText(infoFileName, card.name, 'Unknown Filename'); // Original filename
            setText(infoCreator, card.creator, 'Unknown Creator');

            // Forte Status
            if (infoForteStatus) {
                infoForteStatus.innerHTML = card.isForte
                    ? '<div class="forte-badge"><i class="fas fa-crown"></i> Forte</div>' // Assumes forte-badge style exists
                    : 'No';
            }

            // Trainer Type Info (Show/Hide)
            const isTrainer = card.cardType === 'Trainer';
            if (infoTrainerTypeContainer) infoTrainerTypeContainer.style.display = (isTrainer && card.trainerType) ? '' : 'none';
            if (isTrainer) setText(infoTrainerType, card.trainerType);

            // Type Badges (Clear and Rebuild)
            if (infoTypeBadges) {
                infoTypeBadges.innerHTML = ''; // Clear previous badges
                if (card.types?.length > 0) {
                    card.types.forEach(type => {
                        const badge = document.createElement('span');
                        badge.className = `card-type-badge type-${type?.toLowerCase() ?? 'unknown'}`; // Ensure lowercase for class
                        badge.innerHTML = `<i class="fas fa-tag"></i> ${type || 'Unknown'}`; // Assumes card-type-badge style exists
                        infoTypeBadges.appendChild(badge);
                    });
                } else if (isTrainer) {
                    const badge = document.createElement('span'); badge.className = 'card-type-badge type-trainer'; badge.innerHTML = '<i class="fas fa-user"></i> Trainer'; infoTypeBadges.appendChild(badge);
                } else if (card.cardType === 'Energy') {
                    const badge = document.createElement('span'); badge.className = 'card-type-badge type-energy'; badge.innerHTML = '<i class="fas fa-bolt"></i> Energy'; infoTypeBadges.appendChild(badge);
                }
            }
        }

    /**
     * Checks if a blank/normal counterpart exists using pre-calculated data from image_data.js.
     * Updates lightbox button states and stores paths.
     */
     function checkBlankVersion(card) {
        fancyHasBlankVersion = false; // Assume no counterpart initially
        fancyNormalVersionPath = null;
        fancyBlankVersionPath = null;

        if (card) {
            // --- Use the flags generated by the script ---
            // A counterpart exists *if and only if* BOTH flags are true for the pair.
            // We check the specific flags based on whether the current card is blank or normal.
            if (card.isBlank) {
                // Current card is BLANK. Check if its NORMAL counterpart exists.
                fancyHasBlankVersion = card.hasNormalCounterpart ?? false;
                fancyNormalVersionPath = card.normalCounterpartPath; // Path to normal (might be null)
                fancyBlankVersionPath = card.path; // Path to current blank
            } else {
                // Current card is NORMAL. Check if its BLANK counterpart exists.
                fancyHasBlankVersion = card.hasBlankCounterpart ?? false;
                fancyNormalVersionPath = card.path; // Path to current normal
                fancyBlankVersionPath = card.blankCounterpartPath; // Path to blank (might be null)
            }
            console.log(`[CheckBlank] For ${card.path}: isBlank=${card.isBlank}, hasNormalCounterpart=${card.hasNormalCounterpart}, hasBlankCounterpart=${card.hasBlankCounterpart}`);
        } else {
             console.warn("[CheckBlank] Called with null/undefined card.");
        }

        // Enable/disable textless button based *only* on the flag determined above
        fancyTextlessView.disabled = !fancyHasBlankVersion;
        console.log("[CheckBlank] Textless button disabled:", fancyTextlessView.disabled);

        // Set active button state based on the card currently being viewed
        fancyNormalView.classList.toggle('active', !card?.isBlank);
        fancyTextlessView.classList.toggle('active', !!card?.isBlank);
    }

        /** Updates the enabled/disabled state of lightbox navigation buttons */
        function updateFancyNavigation() {
            fancyPrevButton.disabled = currentImageIndex <= 0;
            fancyNextButton.disabled = currentImageIndex >= currentImageFiles.length - 1;
        }

        /** Navigates to the previous image in the lightbox sequence */
        function showPreviousCard() {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                const prevImage = currentImageFiles[currentImageIndex];
                currentFancyCardImage = prevImage; // Update the context object
                loadFancyCardImage(prevImage.path); // Load the image (async)
                updateCardInfo(prevImage);
                checkBlankVersion(prevImage);
                updateFancyNavigation();
                highlightThumbnail(prevImage.path);
                resetZoom();
                updateLightboxLikeStatus(prevImage.path);
                preloadAdjacentLightboxImages(); // Preload based on new index
            }
        }

        /** Navigates to the next image in the lightbox sequence */
        function showNextCard() {
            if (currentImageIndex < currentImageFiles.length - 1) {
                currentImageIndex++;
                const nextImage = currentImageFiles[currentImageIndex];
                currentFancyCardImage = nextImage; // Update the context object
                loadFancyCardImage(nextImage.path); // Load the image (async)
                updateCardInfo(nextImage);
                checkBlankVersion(nextImage);
                updateFancyNavigation();
                highlightThumbnail(nextImage.path);
                resetZoom();
                updateLightboxLikeStatus(nextImage.path);
                preloadAdjacentLightboxImages(); // Preload based on new index
            }
        }

        /** Switches between Normal and Textless views in the lightbox */
        function switchCardView(view) {
            if (!fancyHasBlankVersion || !currentFancyCardImage) return;
            // Determine current view state based on button class (more reliable than object state if object wasn't updated)
            const currentlyViewingBlank = fancyTextlessView.classList.contains('active');
            let targetPath = '';
            let targetObject = null; // Attempt to find the matching object for info panel update

            if (view === 'normal' && currentlyViewingBlank) {
                targetPath = fancyNormalVersionPath;
                targetObject = baseImageSet.find(img => img.path === targetPath);
            } else if (view === 'textless' && !currentlyViewingBlank) {
                targetPath = fancyBlankVersionPath;
                targetObject = baseImageSet.find(img => img.path === targetPath);
            } else {
                return; // No change needed or invalid request
            }

            if (targetPath) {
                loadFancyCardImage(targetPath); // Load the target image view
                // Update button active states
                fancyNormalView.classList.toggle('active', view === 'normal');
                fancyTextlessView.classList.toggle('active', view === 'textless');
                // If we found the corresponding object, update the info panel and context
                if (targetObject) {
                    updateCardInfo(targetObject);
                    currentFancyCardImage = targetObject;
                } else {
                    console.warn(`[Switch View] Could not find matching object for path: ${targetPath}. Info panel might not reflect view.`);
                    // Decide: Keep old info? Clear info? Update partially?
                    // updateCardInfo(currentFancyCardImage); // Keep old info for now
                }
            }
            resetZoom(); // Reset zoom state when view changes
        }

        /** Closes the Fancy Lightbox */
        function closeFancyLightbox() {
            fancyLightbox.classList.remove('visible');
            fancyLightbox.setAttribute('aria-hidden', 'true');
            resetFancyHoloEffect(); // Reset lightbox holo
            resetZoom(); // Reset zoom
            document.body.style.overflow = ''; // Restore body scroll
            pauseBackgroundAnimation(false); // Resume background animation
            window.scrollTo({ top: lastScrollY, behavior: 'instant' }); // Restore scroll position

            // Find the thumbnail that was opened to refocus it
            const focusedImageObject = currentImageFiles?.[currentImageIndex];
            const opener = focusedImageObject
                ? itemGallery.querySelector(`.thumbnail[data-path="${CSS.escape(focusedImageObject.path)}"]`) // Use CSS.escape for safety
                : null;

            unhighlightAllThumbnails(); // Remove highlight from gallery

            // Refocus the opener thumbnail after a short delay
            setTimeout(() => {
                if (opener) {
                    opener.focus({ preventScroll: true }); // Prevent page jump on focus
                } else if (focusableElements.length > 0) {
                    focusableElements[0].focus({ preventScroll: true }); // Fallback focus
                }
            }, 10);
        }

        /** Lightbox Zoom In */
        function zoomIn() {
            resetFancyHoloEffect(); // Disable holo effect when zoomed
            fancyHoloInner.classList.remove('zoom-out');
            fancyHoloInner.classList.add('zoom-in');
            fancyHoloContainer.classList.add('zoomed');
            isZoomed = true;
        }

        /** Lightbox Zoom Out */
        function zoomOut() {
            resetFancyHoloEffect(); // Disable holo effect when zoomed
            fancyHoloInner.classList.remove('zoom-in');
            fancyHoloInner.classList.add('zoom-out');
            fancyHoloContainer.classList.add('zoomed'); // Still visually zoomed container
            isZoomed = true; // Still considered zoomed out (not default state)
        }

        /** Lightbox Reset Zoom */
        function resetZoom() {
            fancyHoloInner.classList.remove('zoom-in', 'zoom-out');
            fancyHoloContainer.classList.remove('zoomed');
            isZoomed = false;
            // Holo effect will re-enable on next pointer move if applicable
        }

        /** Highlights the corresponding thumbnail in the gallery */
        function highlightThumbnail(imagePath) {
            unhighlightAllThumbnails(); // Clear previous highlight
            if (!imagePath) return;
            try {
                // Use CSS.escape for robustness with special characters in paths
                const thumb = itemGallery.querySelector(`.thumbnail[data-path="${CSS.escape(imagePath)}"]`);
                if (thumb) {
                    thumb.classList.add('selected-inline'); // Add highlight class
                }
            } catch (e) {
                console.error("Error finding thumbnail to highlight:", imagePath, e);
            }
        }

        /** Removes highlight from all gallery thumbnails */
        function unhighlightAllThumbnails() {
            const selected = itemGallery.querySelectorAll('.thumbnail.selected-inline');
            selected.forEach(thumb => thumb.classList.remove('selected-inline'));
        }

      // ===============================================
        // === GALLERY RENDERING & LAZY LOADING (Updated) ===
        // ===============================================

        /** Sets up the IntersectionObserver for lazy loading gallery images */
        function setupIntersectionObserver() {
            // Check if IntersectionObserver is supported
            if (!('IntersectionObserver' in window)) {
                console.warn("IntersectionObserver not supported. Lazy loading disabled.");
                // As a fallback, you might consider manually triggering the load
                // for all images here if needed, though it defeats lazy loading.
                // Example fallback: document.querySelectorAll('#item-gallery img[data-src]').forEach(img => { if(img.dataset.src) img.src = img.dataset.src; });
                return; // Exit if not supported
            }

            const observerOptions = {
                root: null, // Observe intersections relative to the viewport
                rootMargin: '250px 0px 250px 0px', // Load images when they are 250px below/above viewport edge vertically
                threshold: 0.01 // Trigger as soon as even a tiny part is visible
            };

            intersectionObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    const thumbnail = entry.target; // The .thumbnail div being observed
                    const img = thumbnail.querySelector('img'); // The img element inside
                    if (!img) return; // Skip if somehow no image tag found

                    if (entry.isIntersecting) {
                        // Element is intersecting the viewport (or margin)
                        thumbnail.classList.add('in-view');

                        // Load the actual image if it hasn't been loaded yet (has data-src)
                        if (img.dataset.src) {
                            const imagePath = img.dataset.src;
                            // console.log(`[Lazy Load] Loading image in view: ${imagePath}`); // Optional debug log
                            img.src = imagePath; // Setting src triggers the browser load
                            // It's crucial to remove data-src *after* setting src,
                            // otherwise this logic might run again if observer triggers rapidly.
                            delete img.dataset.src;

                            // Optimization: Preload adjacent gallery items for smoother scrolling feel
                            preloadAdjacentGalleryImages(thumbnail); // Assumes this function exists
                        }
                        // Note: We don't unobserve here, element can transition in/out multiple times
                    } else {
                        // Element is *not* intersecting
                        thumbnail.classList.remove('in-view');
                        // Reset holo effect if it scrolls completely out of view
                        // Assumes resetHoloEffect function exists
                        resetHoloEffect(thumbnail, true);
                    }
                });
            }, observerOptions);
        }

        /**
         * Renders the gallery thumbnails based on the provided image objects.
         * IMPORTANT: This function now renders *exactly* the list it receives,
         * expecting `applyFiltersAndRender` to have already handled blank/normal prioritization.
         */
        function renderGalleryView(imagesToDisplayInGrid) { // Parameter name clarifies input
            console.log(`[Render] Rendering gallery grid with ${imagesToDisplayInGrid?.length ?? 0} images.`);

            // Clean up observer from previous items before clearing HTML
            if (intersectionObserver) {
                itemGallery.querySelectorAll('.thumbnail').forEach(thumb => intersectionObserver.unobserve(thumb));
            }

            itemGallery.innerHTML = ''; // Clear previous gallery content
            focusableElements = []; // Reset focusable elements array
            // Note: currentlyDisplayedImages (the *full* filtered list) is still stored globally if needed elsewhere

            const imagesToRender = imagesToDisplayInGrid || []; // Use the processed list passed in
            const hasContent = imagesToRender.length > 0;

            // *** The internal filter for !img.isBlank has been REMOVED ***
            console.log(`[Render] Displaying ${imagesToRender.length} images in grid (now includes blank-only cards).`);

            const fragment = document.createDocumentFragment(); // Use fragment for performance

            imagesToRender.forEach((image) => { // Iterate over the exact list provided
                const thumbnailContainer = document.createElement('div');
                thumbnailContainer.className = 'thumbnail'; // Base class for styling from theme.css
                thumbnailContainer.setAttribute('tabindex', '0');
                thumbnailContainer.setAttribute('role', 'button');
                thumbnailContainer.dataset.path = image.path; // Store path for identification

                // Store the full object, ensures consistency when opening lightbox
                try {
                    thumbnailContainer.dataset.object = JSON.stringify(image);
                } catch (e) {
                    console.error("Failed to stringify image object for data attribute:", image, e);
                    // Skip this thumbnail if data can't be stored? Or add error state?
                    return; // Skip this iteration
                }

                thumbnailContainer.setAttribute('aria-label', `Image: ${image.cardName || image.name}`);
                // Create a safer ID from path for hover timeout tracking etc.
                thumbnailContainer.id = `thumbnail-${image.path.replace(/[^a-zA-Z0-9_-]/g, '-')}`;

                const img = document.createElement('img');
                const encodedPath = encodeImagePath(image.path); // Assumes encodeImagePath exists

                // --- Setup for Lazy Loading ---
                img.src = placeholderUrl; // Show placeholder initially
                img.dataset.src = encodedPath; // Store real path in data-src for the observer
                img.alt = `Thumbnail ${image.cardName || image.name}`;
                // Add necessary classes - ensure 'gallery-image' is defined in your CSS
                img.className = 'gallery-image w-full h-auto block pointer-events-none';
                img.loading = 'lazy'; // Native browser lazy loading hint

                // --- Image Load/Error Handlers ---
                img.onload = function() {
                    img.classList.add('loaded');
                    // Aspect ratio / border radius logic (keep your original implementation)
                    if (img.naturalWidth && img.naturalHeight) {
                        const aspectRatio = img.naturalWidth / img.naturalHeight;
                        const borderRadiusMultiplier = Math.min(Math.max(aspectRatio, 0.5), 1.5);
                        thumbnailContainer.style.setProperty('--image-aspect-ratio', aspectRatio);
                        thumbnailContainer.style.borderRadius = `${5 * borderRadiusMultiplier}% / ${3.5 / borderRadiusMultiplier}%`;
                    } else {
                        thumbnailContainer.style.borderRadius = `${5 * 0.75}% / ${3.5 / 0.75}%`; // Fallback
                    }
                };
                img.onerror = function() {
                    console.error(`Failed to load gallery image: ${image.path}`);
                    img.src = placeholderUrl; // Ensure placeholder is shown
                    img.classList.add('load-error'); // Add class for styling error state
                    thumbnailContainer.style.cursor = 'not-allowed';
                    thumbnailContainer.onclick = null; // Disable click
                    thumbnailContainer.onkeydown = null; // Disable keyboard interaction
                    thumbnailContainer.removeAttribute('role');
                    thumbnailContainer.removeAttribute('tabindex');
                };

                // --- Click/Keydown Activation ---
                const activateThumbnail = (eventSourceElement) => {
                    // Retrieve data, check for error class, check for active animation
                    const imgDataStr = eventSourceElement.dataset.object;
                    if (!eventSourceElement.classList.contains('load-error') &&
                        !eventSourceElement.classList.contains('holo-click-active') && imgDataStr) {

                        eventSourceElement.classList.add('holo-click-active');
                        resetHoloEffect(eventSourceElement, false); // Assumes resetHoloEffect exists

                        // Use try-catch for JSON parsing robustness
                        let imageObject = null;
                        try { imageObject = JSON.parse(imgDataStr); }
                        catch (e) { console.error("Error parsing image data on click:", e); }

                        setTimeout(() => {
                            eventSourceElement.classList.remove('holo-click-active');
                            if (imageObject) {
                                openFancyLightbox(imageObject); // Assumes openFancyLightbox exists
                            }
                        }, CLICK_EFFECT_DURATION_MS);
                    }
                };
                thumbnailContainer.addEventListener('click', () => activateThumbnail(thumbnailContainer));
                thumbnailContainer.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); activateThumbnail(thumbnailContainer); }
                });

                // --- Add Like Button/Counter ---
                // Assumes createLikeContainer function exists and works
                const likeContainer = createLikeContainer(image.path);

                // --- Append and Observe ---
                thumbnailContainer.appendChild(img);
                thumbnailContainer.appendChild(likeContainer);
                fragment.appendChild(thumbnailContainer); // Add to fragment

                focusableElements.push(thumbnailContainer); // Add to list for keyboard nav

                // Observe thumbnail for lazy loading if observer exists
                if (intersectionObserver) {
                    intersectionObserver.observe(thumbnailContainer);
                } else {
                    // Fallback if no observer: Load image immediately
                    if (img.dataset.src) { img.src = img.dataset.src; delete img.dataset.src; }
                    thumbnailContainer.classList.add('in-view'); // Assume it's in view
                }
            });

            itemGallery.appendChild(fragment); // Append all generated thumbnails at once
            emptyFolderMessage.classList.toggle('hidden', !hasContent); // Update empty message visibility
            currentFocusIndex = 0; // Reset focus index
            updateAllThumbnailLikes(); // Update like states after rendering // Assumes exists
        }

    // --- End of Updated Gallery Rendering & Lazy Loading Section ---


        // ===============================================
        // === LIKE BUTTON LOGIC =========================
        // ===============================================

        /** Helper to create the like button/counter structure for a thumbnail */
        function createLikeContainer(imagePath) {
             // Assumes getLikeData is available globally from db-likes.js
             const likeData = window.getLikeData ? window.getLikeData(imagePath) : { count: 0, liked: false };
             const likeContainer = document.createElement('div');
             likeContainer.className = 'thumbnail-like-container'; // Style via CSS
             likeContainer.innerHTML = `
                <span class="thumbnail-like-count">${likeData.count}</span>
                <button class="thumbnail-like-button" aria-label="Like this card">
                    <i class="fa-heart ${likeData.liked ? 'fas' : 'far'}"></i> </button>`;

             // Attach click listener to the button within this container
             const likeButton = likeContainer.querySelector('.thumbnail-like-button');
             likeButton.addEventListener('click', (e) => {
                 e.stopPropagation(); // Prevent triggering thumbnail click (opening lightbox)
                 if (window.toggleLike) { // Assumes toggleLike is global
                     window.toggleLike(imagePath);
                     updateAllThumbnailLikes(); // Update counts/icons on all visible thumbnails
                     // If the lightbox is open and showing this specific card, update its like button too
                     if (fancyLightbox.classList.contains('visible') && currentFancyCardImage?.path === imagePath) {
                         updateLightboxLikeStatus(imagePath);
                     }
                 } else {
                     console.warn("toggleLike function not found.");
                 }
             });
             return likeContainer;
        }

        /** Updates the like count and icon state for ALL visible thumbnails */
        function updateAllThumbnailLikes() {
            if (!window.getLikeData) return; // Exit if function is missing
            // Iterate over thumbnails currently in the DOM
            itemGallery.querySelectorAll('.thumbnail[data-path]').forEach(thumbnail => {
                const path = thumbnail.dataset.path;
                const likeContainer = thumbnail.querySelector('.thumbnail-like-container');
                if (!likeContainer || !path) return; // Skip if no container or path

                const countEl = likeContainer.querySelector('.thumbnail-like-count');
                const iconEl = likeContainer.querySelector('.thumbnail-like-button i');
                const likeData = window.getLikeData(path) || { count: 0, liked: false }; // Get current data

                if (countEl) countEl.textContent = likeData.count; // Update count display
                if (iconEl) { // Update icon style (solid/regular heart)
                    iconEl.classList.toggle('fas', likeData.liked);
                    iconEl.classList.toggle('far', !likeData.liked);
                }
            });
        }

        /** Updates the like count and icon state specifically for the lightbox */
        function updateLightboxLikeStatus(imagePath) {
            if (!lbLikeButton || !lbLikeCount || !window.getLikeData || !imagePath) return;

            const likeData = window.getLikeData(imagePath) || { count: 0, liked: false };
            lbLikeCount.textContent = likeData.count; // Update count display
            const iconElement = lbLikeButton.querySelector('i');

            lbLikeButton.classList.toggle('liked', likeData.liked); // Add/remove 'liked' class for potential styling
            if (iconElement) { // Update icon style
                iconElement.classList.toggle('fas', likeData.liked);
                iconElement.classList.toggle('far', !likeData.liked);
            }

            // Ensure the click handler is always set correctly for the *current* image path
            // Use direct assignment to overwrite any previous listener
            lbLikeButton.onclick = () => {
                if (window.toggleLike) {
                    window.toggleLike(imagePath);
                    updateLightboxLikeStatus(imagePath); // Update lightbox UI immediately
                    updateAllThumbnailLikes(); // Update gallery UI in background
                }
            };
        }

        

    // ======================================================================
    // === START: PASTE THIS BLOCK where lines 1057-1222 used to be ========
    // ======================================================================

    // === FILTERING AND TABS (Restored & Updated Logic) ===

    /**
     * Applies current filter state, determines which card versions to display in the gallery
     * (prioritizing normal), and triggers rendering.
     */
     function applyFiltersAndRender() {
        console.log(`[Filter] Applying: Type='${currentTypeFilter}', Forte='${currentForteFilter}', Trainer='${currentTrainerTypeFilter}', Creator='${currentCreatorFilter}' on Set: ${currentSetTab}`);
        console.log(`[Filter] Base set size for tab '${currentSetTab}': ${baseImageSet.length}`);

        // --- Step 1: Filter baseImageSet based on current filter controls ---
        let filteredImages = baseImageSet.filter(img => {
            const typeMatch = currentTypeFilter === 'all' || img.cardType === currentTypeFilter;
            const forteMatch = currentForteFilter === 'all' ||
                               (currentForteFilter === 'yes' && img.isForte === true) ||
                               (currentForteFilter === 'no' && img.isForte === false);
            const trainerMatch = currentTrainerTypeFilter === 'all' ||
                               ((currentTypeFilter === 'all' || img.cardType === 'Trainer') && img.trainerType === currentTrainerTypeFilter);
            const creatorMatch = currentCreatorFilter === 'all' || img.creator === currentCreatorFilter;
            return typeMatch && forteMatch && trainerMatch && creatorMatch;
        });
        console.log(`[Filter] Found ${filteredImages.length} images matching controls (incl. blanks).`);

        // Store this full filtered list
        currentlyDisplayedImages = filteredImages;

        // --- Step 2: Determine the final list to RENDER in the gallery grid ---
        // Use Map to ensure only one version per card (prioritizing normal)
        const imagesToRenderMap = new Map();
        const BLANK_SUFFIX_INTERNAL = '-BL-'; // Local constant

        for (const image of filteredImages) {
            // Ensure isBlank property is available (should be from generator)
            const isBlank = image.isBlank ?? (image.name?.includes(BLANK_SUFFIX_INTERNAL) ?? false);
            const ext = getExtension(image.name); // Assumes getExtension exists
            const baseName = isBlank ? image.name.replace(BLANK_SUFFIX_INTERNAL + ext, '') : image.name.replace(ext, '');
            const cardKey = `${image.setName || 'UnknownSet'}_${baseName}`; // Unique key per card/set

            const existingEntry = imagesToRenderMap.get(cardKey);

            if (!existingEntry || (existingEntry.isBlank && !isBlank)) {
                // Add if no entry exists, OR if existing is blank and current is normal (overwrite)
                imagesToRenderMap.set(cardKey, { ...image, isBlank }); // Ensure isBlank is correctly set on the object added
            }
            // If existing is normal and current is blank, do nothing (keep the normal version)
        }
        const imagesToRenderInGallery = Array.from(imagesToRenderMap.values());
        console.log(`[Filter] Determined ${imagesToRenderInGallery.length} unique cards to render in gallery.`);

        // --- Step 3: Render the gallery with the processed list ---
        // Assumes renderGalleryView exists and renders the list it's given without internal filtering
        renderGalleryView(imagesToRenderInGallery);
    }

    /** Populates filter dropdowns based on available data */
    function populateFilters() {
        // Assumes filterConfig, typeFilterSelect, trainerTypeFilterSelect, creatorFilterSelect, allCreators are available in the script's scope
        if (!filterConfig || !typeFilterSelect || !trainerTypeFilterSelect || !creatorFilterSelect) {
            console.error("[Populate Filters] Missing config or select elements."); return;
        }
        console.log("[Populate Filters] Using Config:", filterConfig);

        const clearOptions = (selectElement) => { while (selectElement.options.length > 1) selectElement.remove(1); };

        clearOptions(typeFilterSelect);
        filterConfig.typeOrder?.forEach(type => { if (type) typeFilterSelect.add(new Option(type, type)); });

        clearOptions(trainerTypeFilterSelect);
        filterConfig.trainerTypeOrder?.forEach(type => { if (type) trainerTypeFilterSelect.add(new Option(type, type)); });

        clearOptions(creatorFilterSelect);
        const sortedCreators = Array.from(allCreators).filter(Boolean).sort(); // Uses global allCreators
        console.log("[Populate Filters] Populating creators:", sortedCreators);
        sortedCreators.forEach(creator => { creatorFilterSelect.add(new Option(creator, creator)); });
    }

    /** Renders the set navigation tabs based on filterConfig and available data */
    function renderTabs() {
        // Assumes tabContainer, rootImageStructure, filterConfig, getAllImageFilesRecursive, hexToRgba, lightenHexColor are available in the script's scope
        if (!tabContainer || !rootImageStructure || !filterConfig?.setOrder || !filterConfig?.setColors) {
            console.error("[Render Tabs] Missing elements or required config."); return;
        }
        const label = tabContainer.querySelector('h2'); tabContainer.innerHTML = ''; if (label) tabContainer.appendChild(label);

        // Assumes getAllImageFilesRecursive is defined elsewhere and populates allCreators if needed again
        const allImagesForSets = getAllImageFilesRecursive(rootImageStructure);
        const availableSetNames = new Set(allImagesForSets.map(img => img.setName).filter(name => name && name !== "Misc"));
        console.log("[Render Tabs] Available sets:", Array.from(availableSetNames));

        // Helper to create a tab button (defined locally within renderTabs)
        const createTabButton = (setName, text) => {
            const button = document.createElement('button');
            button.className = 'tab';
            button.dataset.setName = setName;
            const tabColor = filterConfig.setColors[setName] || filterConfig.setColors['default'] || '#6B7280';
            button.style.setProperty('--tab-active-border-color', tabColor);
            button.style.setProperty('--tab-active-bg-color', hexToRgba(tabColor, 0.3)); // Assumes hexToRgba is defined
            const textSpan = document.createElement('span');
            const displayText = (setName === "Other") ? "Unbound" : text;
            textSpan.textContent = displayText;
            if (setName === "Other") {
                button.style.setProperty('--tab-active-text-color', '#A020F0'); // Example specific color
            } else {
                button.style.setProperty('--tab-active-text-color', lightenHexColor(tabColor, 0.8)); // Assumes lightenHexColor is defined
            }
            button.appendChild(textSpan);
            return button;
        };

        const allTab = createTabButton('all', 'All'); allTab.classList.add('active'); tabContainer.appendChild(allTab);
        filterConfig.setOrder.forEach(setName => { if (availableSetNames.has(setName)) tabContainer.appendChild(createTabButton(setName, setName)); });

        // Attach event listener (ensure it's only attached once)
        if (!tabContainer.dataset.listenerAttached) {
            tabContainer.addEventListener('click', (e) => {
                const clickedTab = e.target.closest('.tab');
                if (clickedTab && !clickedTab.classList.contains('active')) {
                    const newSetName = clickedTab.dataset.setName;
                    tabContainer.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                    clickedTab.classList.add('active');
                    currentSetTab = newSetName; // Update global state

                    // Update global baseImageSet
                    // Assumes getAllImageFilesRecursive is safe to call again or structure is static
                    const allImagesFull = getAllImageFilesRecursive(rootImageStructure);
                    if (newSetName === 'all') {
                        baseImageSet = allImagesFull.filter(img => img.setName !== "Misc");
                    } else {
                        baseImageSet = allImagesFull.filter(img => img.setName === newSetName);
                    }
                    console.log(`[Tab Click] Set base set to '${newSetName}': ${baseImageSet.length} images.`);
                    applyFiltersAndRender(); // Call global applyFiltersAndRender
                }
            });
            tabContainer.dataset.listenerAttached = 'true';
        }
    }

        // ===============================================
        // === KEYBOARD NAV & HOLO EFFECTS =============
        // ===============================================
        // --- (These functions are restored verbatim from your initial script) ---

        /** Handles keyboard navigation within the gallery grid */
        function handleGalleryKeyDown(e) {
             if (focusableElements.length === 0 || fancyLightbox.classList.contains('visible')) return;

             // Calculate number of columns based on computed style
             const gridElement = document.getElementById('item-gallery');
             const gridStyle = window.getComputedStyle(gridElement);
             const gridColsText = gridStyle.getPropertyValue('grid-template-columns');
             // Simple count of space-separated values - adjust if grid definition is complex
             const gridCols = gridColsText.split(' ').filter(s => s && s !== '0px').length || 1; // Fallback to 1 column

             let nextFocusIndex = currentFocusIndex;
             let shouldPreventDefault = true;

             switch (e.key) {
                 case 'ArrowRight': nextFocusIndex = (currentFocusIndex + 1); break;
                 case 'ArrowLeft': nextFocusIndex = (currentFocusIndex - 1); break;
                 case 'ArrowDown': nextFocusIndex = Math.min(currentFocusIndex + gridCols, focusableElements.length - 1); break;
                 case 'ArrowUp': nextFocusIndex = Math.max(currentFocusIndex - gridCols, 0); break;
                 case 'Home': nextFocusIndex = 0; break;
                 case 'End': nextFocusIndex = focusableElements.length - 1; break;
                 default: shouldPreventDefault = false; return; // Exit if not a navigation key
             }

             // Clamp index within bounds
             nextFocusIndex = Math.max(0, Math.min(nextFocusIndex, focusableElements.length - 1));

             if (nextFocusIndex !== currentFocusIndex) {
                 if (shouldPreventDefault) e.preventDefault(); // Prevent default scroll behavior for arrows/home/end
                 currentFocusIndex = nextFocusIndex;
                 if(focusableElements[currentFocusIndex]) {
                     focusableElements[currentFocusIndex].focus(); // Move focus to the new element
                 }
             }
         }

        /** Handles keyboard events when the lightbox is open */
         function handleFancyLightboxKeyDown(e) {
             if (!fancyLightbox.classList.contains('visible')) return;
             let shouldPreventDefault = true; // Assume prevent default unless key isn't handled

             switch (e.key) {
                 case 'Escape': closeFancyLightbox(); break;
                 case 'ArrowLeft': if (!fancyPrevButton.disabled) showPreviousCard(); break;
                 case 'ArrowRight': if (!fancyNextButton.disabled) showNextCard(); break;
                 case '+': case '=': zoomIn(); break; // Include '=' key
                 case '-': case '_': zoomOut(); break; // Include '_' key
                 case '0': resetZoom(); break;
                 case ' ': // Space bar - Toggle textless view if available
                      if (!fancyTextlessView.disabled) {
                         if (fancyNormalView.classList.contains('active')) switchCardView('textless');
                         else switchCardView('normal');
                      }
                     break; // Space already prevents scroll on buttons
                 default: shouldPreventDefault = false; return; // Exit if key is not handled
             }
             if (shouldPreventDefault) e.preventDefault(); // Prevent default actions (like page scroll for arrows/space)
         }

        /** Applies holo effect listeners to gallery thumbnails */
         function applyHoloListeners(containerSelector) {
             const galleryContainer = document.querySelector(containerSelector);
             if (!galleryContainer) return;
             // Use pointer events for broader compatibility (mouse, pen, maybe touch on some devices)
             galleryContainer.addEventListener('pointermove', handleHoloMove);
             galleryContainer.addEventListener('pointerleave', handleHoloEnd); // Reset when pointer leaves gallery
             galleryContainer.addEventListener('pointerup', handleHoloEnd); // Reset on pointer up (e.g., after drag)
         }

        /** Handles pointer movement for thumbnail holo effect */
         function handleHoloMove(e) {
             if (e.pointerType === 'touch') return; // Typically ignore touch for hover effects

             const target = e.target.closest('.thumbnail');
             // Check if target is valid, in view, not click-animating, and not an error placeholder
              if (!target || !target.classList.contains('in-view') || target.classList.contains('holo-click-active') || target.querySelector('.load-error')) {
                 // Reset any *other* active holo if moving over a non-holo element
                  const activeHolo = itemGallery.querySelector('.thumbnail.holo-active:not(.holo-click-active)');
                  if(activeHolo && activeHolo !== target) resetHoloEffect(activeHolo);
                 return;
             }

             // Reset other active elements first
              const otherActiveHolo = itemGallery.querySelector('.thumbnail.holo-active:not(.holo-click-active)');
              if(otherActiveHolo && otherActiveHolo !== target) resetHoloEffect(otherActiveHolo);

             // --- Holo Calculation Logic (from original script) ---
             const rect = target.getBoundingClientRect();
             const clientX = e.clientX; const clientY = e.clientY;
             const offsetX = clientX - rect.left; const offsetY = clientY - rect.top;
             const w = target.offsetWidth; const h = target.offsetHeight;
             if (w === 0 || h === 0) return; // Avoid division by zero
             const px = (offsetX / w) * 100; const py = (offsetY / h) * 100;
             const dist_x = Math.abs(px - 50); const dist_y = Math.abs(py - 50);
             const max_angle = 10; // Max rotation
             const rotate_y = ((px - 50) / 50) * max_angle;
             const rotate_x = ((py - 50) / 50) * -max_angle; // Invert X
             const lp = 50 + rotate_y * -0.6; // Gradient position X
             const tp = 50 + rotate_x * 0.6; // Gradient position Y
             const px_spark = 50 + (px - 50) / 7; // Sparkle position X
             const py_spark = 50 + (py - 50) / 7; // Sparkle position Y
             const p_opc = Math.min(Math.max(0.3 + (dist_x + dist_y) / 100 * 0.8, 0.3), 0.9); // Sparkle opacity
             // --- End Holo Calculation ---

             // Apply styles
             target.classList.add('holo-active');
             target.style.setProperty('--thumb-gradient-pos-x', `${lp}%`);
             target.style.setProperty('--thumb-gradient-pos-y', `${tp}%`);
             target.style.setProperty('--thumb-sparkle-pos-x', `${px_spark}%`);
             target.style.setProperty('--thumb-sparkle-pos-y', `${py_spark}%`);
             target.style.setProperty('--thumb-sparkle-opacity', p_opc);
             target.style.transform = `perspective(900px) rotateX(${rotate_x}deg) rotateY(${rotate_y}deg) scale(1.03)`; // 3D Tilt

             // Timeout to reset effect if pointer stops moving over the element
             clearHoverEffectTimeout(target.id);
             setHoverEffectTimeout(target.id, () => {
                 const currentHoverTarget = document.elementFromPoint(clientX, clientY)?.closest('.thumbnail');
                 if (currentHoverTarget === target) resetHoloEffect(target); // Only reset if still hovering this one
             }, HOVER_EFFECT_TIMEOUT_MS);
         }

        /** Clears the hover effect reset timeout for a specific element */
         function clearHoverEffectTimeout(elementId) {
             if (hoverEffectTimeouts.has(elementId)) {
                 clearTimeout(hoverEffectTimeouts.get(elementId));
                 hoverEffectTimeouts.delete(elementId);
             }
         }

        /** Sets the hover effect reset timeout for a specific element */
         function setHoverEffectTimeout(elementId, callback, timeout) {
             clearHoverEffectTimeout(elementId); // Ensure no previous timeout exists
             const timeoutId = setTimeout(callback, timeout);
             hoverEffectTimeouts.set(elementId, timeoutId);
         }

        /** Handles pointer leaving a thumbnail or the gallery container */
         function handleHoloEnd(e) {
             const target = e.target.closest('.thumbnail');
             // Check if the pointer is leaving the thumbnail itself (relatedTarget is where it's going)
             const relatedTarget = e.relatedTarget ? e.relatedTarget.closest('.thumbnail') : null;
             // Reset if leaving the target thumbnail and it was active (and not click-animating)
             if (target && target !== relatedTarget && target.classList.contains('holo-active') && !target.classList.contains('holo-click-active')) {
                 resetHoloEffect(target);
             }
         }

        /** Resets the holo effect styles on a thumbnail */
         function resetHoloEffect(element, resetTransform = true) {
             if (!element) return;
             element.classList.remove('holo-active');
             // Only reset transform if requested and not in click animation
             if (resetTransform && !element.classList.contains('holo-click-active')) {
                 element.style.transform = ''; // Reset transform
             }
             // Remove CSS variables
             element.style.removeProperty('--thumb-gradient-pos-x');
             element.style.removeProperty('--thumb-gradient-pos-y');
             element.style.removeProperty('--thumb-sparkle-pos-x');
             element.style.removeProperty('--thumb-sparkle-pos-y');
             element.style.removeProperty('--thumb-sparkle-opacity');
             // Clear any pending reset timeout for this element
             if (element.id) clearHoverEffectTimeout(element.id);
         }

        /** Applies holo effect listeners to the lightbox image container */
         function applyFancyHoloListeners(containerSelector) {
             const container = document.querySelector(containerSelector);
             if (!container) return;
             container.addEventListener('pointermove', handleFancyHoloMove);
             container.addEventListener('pointerleave', handleFancyHoloEnd);
             container.addEventListener('pointerup', handleFancyHoloEnd); // Also reset on pointer up
         }

        /** Handles pointer movement for lightbox holo effect */
         function handleFancyHoloMove(e) {
             if (e.pointerType === 'touch' || isZoomed) { resetFancyHoloEffect(); return; } // Disable if touch or zoomed
             const container = fancyHoloContainer; const target = fancyHoloInner;
             if (!container || !target) return;
             // --- Holo Calculation Logic (from original script) ---
             const rect = container.getBoundingClientRect();
             let clientX = e.clientX; let clientY = e.clientY;
             const relativeX = clientX - rect.left; const relativeY = clientY - rect.top;
             const percentX = (relativeX / rect.width) * 100; const percentY = (relativeY / rect.height) * 100;
             const max_angle = 15; // Adjust intensity
             const rotateY = ((percentX / 100) - 0.5) * max_angle * 2;
             const rotateX = (((percentY / 100) - 0.5) * -max_angle * 2);
             const normX = percentX / 100; const normY = percentY / 100;
             const gradientX = 50 + ((percentX - 50) / -1.5); // Opposite direction
             const gradientY = 50 + ((percentY - 50) / -1.5);
             const sparkleX = 50 + ((percentX - 50) / 5); // Subtler movement
             const sparkleY = 50 + ((percentY - 50) / 5);
             const distFromCenter = Math.sqrt(Math.pow((normX - 0.5) * 2, 2) + Math.pow((normY - 0.5) * 2, 2));
             const sparkleOpacity = Math.min(0.4 + distFromCenter * 0.6, 0.9);
             // --- End Holo Calculation ---

             // Apply styles
             target.classList.add('holo-active');
             target.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
             target.style.setProperty('--lb-gradient-pos-x', `${gradientX}%`);
             target.style.setProperty('--lb-gradient-pos-y', `${gradientY}%`);
             target.style.setProperty('--lb-sparkle-pos-x', `${sparkleX}%`);
             target.style.setProperty('--lb-sparkle-pos-y', `${sparkleY}%`);
             target.style.setProperty('--lb-sparkle-opacity', sparkleOpacity);

             // Timeout to reset effect if pointer stops
             clearTimeout(fancyActiveHoloTimeout);
             fancyActiveHoloTimeout = setTimeout(() => {
                 const currentElement = document.elementFromPoint(clientX, clientY);
                 if (container.contains(currentElement)) resetFancyHoloEffect(); // Only reset if still inside
             }, HOVER_EFFECT_TIMEOUT_MS);
         }

        /** Handles pointer leaving the lightbox container */
         function handleFancyHoloEnd(e) {
             if (isZoomed) return; // Don't reset if zoomed
             const target = fancyHoloInner; if (!target) return;
             // Reset if leaving the main container
             const relatedTarget = e.relatedTarget;
             if (!relatedTarget || !fancyHoloContainer.contains(relatedTarget)) {
                 resetFancyHoloEffect();
             }
         }

        /** Resets the holo effect styles on the lightbox image */
         function resetFancyHoloEffect() {
             const target = fancyHoloInner; if (!target) return;
             target.classList.remove('holo-active');
             if (!isZoomed) target.style.transform = ''; // Reset transform only if not zoomed
             // Remove CSS variables
             target.style.removeProperty('--lb-gradient-pos-x');
             target.style.removeProperty('--lb-gradient-pos-y');
             target.style.removeProperty('--lb-sparkle-pos-x');
             target.style.removeProperty('--lb-sparkle-pos-y');
             target.style.removeProperty('--lb-sparkle-opacity');
             clearTimeout(fancyActiveHoloTimeout); // Clear pending reset timeout
         }

        /** Applies the selected gallery size class */
        function applyGallerySize(sizeIndex) {
             if (!itemGallery || sizeIndex === undefined || sizeIndex === null) return;
             const validIndex = Math.max(0, Math.min(sizeIndex, Object.keys(GALLERY_SIZE_CLASSES).length - 1));
             // Remove all existing size classes first
             Object.values(GALLERY_SIZE_CLASSES).forEach(cls => itemGallery.classList.remove(cls));
             // Add the active size class
             itemGallery.classList.add(GALLERY_SIZE_CLASSES[validIndex]);
             console.log(`[Size] Applied class: ${GALLERY_SIZE_CLASSES[validIndex]}`);
             if (gallerySizeDisplay) gallerySizeDisplay.textContent = SIZE_MAP[validIndex] || SIZE_MAP[DEFAULT_GALLERY_SIZE_INDEX];
         }

        // ===============================================
        // === APP INITIALIZATION ========================
        // ===============================================

        /** Initializes the application */
        async function initApp() { // Make async to allow await for initial preload
            console.log("[Init] DOM Loaded. Initializing Application...");
            const startTime = performance.now();
// Example listener in your main script (e.g., in initApp)
document.addEventListener('forteSettingChanged', (event) => {
    if (event.detail.setting === 'likesCleared') {
        console.log("[Main] Received likes cleared event. Updating UI.");
        if (typeof updateAllThumbnailLikes === 'function') {
            updateAllThumbnailLikes(); // Update gallery like icons/counts
        }
         // If lightbox is open, update its like status too
         if (fancyLightbox.classList.contains('visible') && currentFancyCardImage) {
             if (typeof updateLightboxLikeStatus === 'function') {
                updateLightboxLikeStatus(currentFancyCardImage.path);
             }
         }
    }
});
            // Fallback timeout to ensure loading overlay is hidden
            const loadTimeout = setTimeout(ensurePageLoaded, 10000); // Extended timeout

            setupIntersectionObserver(); // Setup lazy loading first

            try {
                // --- Step 1: Check for essential dependencies ---
                if (typeof imageData === 'undefined' || !imageData.imageStructure || !imageData.filterConfig) {
                    throw new Error("Global 'imageData' object not found or invalid (check image_data.js).");
                }
                 if (typeof window.getLikeData !== 'function' || typeof window.toggleLike !== 'function') {
                    console.warn("[Init] Like functions (getLikeData, toggleLike) not found (check db-likes.js). Like functionality disabled.");
                    // Optionally disable like buttons here if needed
                }
                console.log("[Init] Dependencies checked.");
                rootImageStructure = imageData.imageStructure;
                filterConfig = imageData.filterConfig;

                // --- Step 2: Initial Data Processing ---
                baseImageSet = getAllImageFilesRecursive(rootImageStructure); // Populate creators, get all image objects
                if (baseImageSet.length === 0) {
                    console.warn("[Init] No image files found in imageStructure.");
                    // Potentially display a specific message if no images at all
                }
                populateFilters(); // Populate filter dropdowns based on data
                renderTabs(); // Render set navigation tabs

                // --- Step 3: Initialize UI Controls (Size Slider) ---
                const savedGallerySize = localStorage.getItem(GALLERY_SIZE_KEY) || DEFAULT_GALLERY_SIZE_INDEX.toString();
                gallerySizeSlider.value = savedGallerySize;
                currentGallerySizeIndex = parseInt(savedGallerySize, 10);
                applyGallerySize(currentGallerySizeIndex); // Apply initial size class
                gallerySizeSlider.addEventListener('input', (e) => {
                    const v = parseInt(e.target.value, 10);
                    applyGallerySize(v);
                    currentGallerySizeIndex = v; // Update state
                    localStorage.setItem(GALLERY_SIZE_KEY, v.toString()); // Save preference
                });

                // --- Step 4: Initial Render ---
                // Set the initial baseImageSet for the 'All' tab (excluding 'Misc' set)
                baseImageSet = getAllImageFilesRecursive(rootImageStructure).filter(img => img.setName !== "Misc");
                console.log(`[Init] Initial base image set ('All' tab, excl Misc): ${baseImageSet.length} items.`);
                applyFiltersAndRender(); // Apply default filters and render the initial gallery view

                // --- Step 5: Preload Initial Images (Optimization) ---
                // This happens after the initial structure is rendered but before overlay hides fully
                await preloadInitialImages(INITIAL_PRELOAD_COUNT);

                // --- Step 6: Attach Event Listeners ---
                // Filter changes
                typeFilterSelect.addEventListener('change', (e) => { currentTypeFilter = e.target.value; applyFiltersAndRender(); });
                forteFilterSelect.addEventListener('change', (e) => { currentForteFilter = e.target.value; applyFiltersAndRender(); });
                trainerTypeFilterSelect.addEventListener('change', (e) => { currentTrainerTypeFilter = e.target.value; applyFiltersAndRender(); });
                creatorFilterSelect.addEventListener('change', (e) => { currentCreatorFilter = e.target.value; applyFiltersAndRender(); });

                // Lightbox controls
                fancyLightboxClose.addEventListener('click', closeFancyLightbox);
                fancyPrevButton.addEventListener('click', showPreviousCard);
                fancyNextButton.addEventListener('click', showNextCard);
                fancyNormalView.addEventListener('click', () => switchCardView('normal'));
                fancyTextlessView.addEventListener('click', () => switchCardView('textless'));
                fancyZoomIn.addEventListener('click', zoomIn);
                fancyZoomOut.addEventListener('click', zoomOut);
                fancyZoomReset.addEventListener('click', resetZoom);

                // Lightbox Dragging Interaction (Restored from original logic)
                let isDragging = false; let dragStartX = 0; let dragStartY = 0; let currentRotateX = 0; let currentRotateY = 0;
                fancyHoloContainer.addEventListener('pointerdown', (e) => {
                     if (isZoomed || e.pointerType === 'touch') return; isDragging = true; fancyHoloContainer.setPointerCapture(e.pointerId); dragStartX = e.clientX; dragStartY = e.clientY;
                     const ts = window.getComputedStyle(fancyHoloInner).transform; if (ts && ts !== 'none') { try { const m = new DOMMatrixReadOnly(ts); currentRotateX = Math.asin(-m.m23)*(180/Math.PI); currentRotateY = Math.atan2(m.m13, m.m33)*(180/Math.PI); } catch(err){ currentRotateX=0; currentRotateY=0; } } else { currentRotateX=0; currentRotateY=0; }
                     fancyHoloContainer.style.cursor = 'grabbing'; fancyHoloInner.style.transition = 'none'; e.preventDefault();
                 });
                 document.addEventListener('pointermove', (e) => {
                     if (!isDragging) return; const dX = e.clientX - dragStartX; const dY = e.clientY - dragStartY; const nRY = currentRotateY + (dX*0.15); const nRX = currentRotateX - (dY*0.15); fancyHoloInner.style.transform = `perspective(1000px) rotateX(${nRX}deg) rotateY(${nRY}deg)`;
                 });
                 document.addEventListener('pointerup', (e) => {
                     if (isDragging) { fancyHoloContainer.releasePointerCapture(e.pointerId); isDragging = false; fancyHoloContainer.style.cursor = 'grab'; if (!isZoomed) { fancyHoloInner.style.transition = 'transform 0.4s ease-out'; fancyHoloInner.style.transform = ''; setTimeout(() => { if (!isDragging) fancyHoloInner.style.transition = ''; }, 400); } else { const ft = window.getComputedStyle(fancyHoloInner).transform; if (ft && ft !== 'none') { try { const m=new DOMMatrixReadOnly(ft); currentRotateX=Math.asin(-m.m23)*(180/Math.PI); currentRotateY=Math.atan2(m.m13,m.m33)*(180/Math.PI); } catch(err){} } } }
                 });
                 fancyHoloContainer.addEventListener('dblclick', () => { if (isZoomed) resetZoom(); else zoomIn(); });


                // Global Keydown Listener
                document.addEventListener('keydown', (e) => {
                    if (fancyLightbox.classList.contains('visible')) {
                        handleFancyLightboxKeyDown(e); // Handle lightbox keys
                    } else {
                        // Handle gallery keys only if focus is likely within gallery/controls
                        const activeElement = document.activeElement;
                        if (activeElement && (itemGallery.contains(activeElement) || tabContainer.contains(activeElement) || activeElement.closest('.controls-area'))) {
                            handleGalleryKeyDown(e);
                        }
                    }
                });

                // Apply Holo effects to gallery thumbnails
                applyHoloListeners('#item-gallery');

                // --- Step 7: Initialization Complete ---
                clearTimeout(loadTimeout); // Clear the fallback timeout
                ensurePageLoaded(); // Hide loading overlay
                const endTime = performance.now();
                console.log(`[Init] Initialization complete in ${(endTime - startTime).toFixed(0)}ms.`);

            } catch (error) {
                // Catch critical errors during initialization
                console.error("[Init] CRITICAL ERROR DURING INITIALIZATION:", error);
                displayError(`Initialization Failed: ${error.message}. Please check the browser console for details and verify external scripts/data (image_data.js, db-likes.js) are loaded correctly.`);
                clearTimeout(loadTimeout); // Ensure timeout is cleared on error
                // ensurePageLoaded(); // Already called in displayError
            }
        }

        // --- Start Application ---
        // Use DOMContentLoaded to ensure HTML is parsed, then run initApp
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp(); // DOM is already ready
        }

    </script>
    <script src="js/legendpopup.js" defer></script>     
    <script src="js/settings.js" defer></script>
     <script src="js/effects.js" defer></script>   
     <script>
        // Your main application script, now with effect functions removed
        // and calls updated to use ForteEffects.*
        // ... (initApp, renderGalleryView, openFancyLightbox, etc.) ...

        /** Initializes the application */
        async function initApp() {
             console.log("[Init] DOM Loaded. Initializing Application...");
             // ... other init code ...

             // Ensure settings are applied (settings.js handles initial load)
             // window.effectsEnabled is now globally available via settings.js

             // ... populate filters, render tabs ...

             // Apply Holo effects to gallery thumbnails via the new module
             if (window.ForteEffects) {
                 ForteEffects.initGalleryHolo('#item-gallery');
             } else {
                 console.error("ForteEffects module not loaded!");
             }

             // ... rest of initApp ...
        }
         // Make sure other functions like openFancyLightbox, closeFancyLightbox,
         // zoomIn, zoomOut, resetZoom, switchCardView, activateThumbnail, etc.
         // now call ForteEffects.resetLightboxHolo() or ForteEffects.resetGalleryHolo()
         // where they previously called the local versions.

        // --- Start Application ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp(); // DOM is already ready
        }
    </script>  
</body>
</html>