<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forte Card Previewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="assets/css/theme.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="image_data.js" defer></script>
    <script src="background.js" defer></script>
    <script src="audio.js" defer></script>
    <script src="likes.js" defer></script>
</head>
<body class="font-sans p-4 md:p-8">
    <!-- Page Loading Overlay -->
    <div id="page-loading-overlay" class="page-loading-overlay">
        <div class="loader-container">
            <div class="loader"></div>
            <div class="loader-text">Loading Forte Card Previewer</div>
        </div>
    </div>

    <div id="threejs-bg"></div>

    <div class="container mx-auto max-w-7xl rounded-lg shadow-lg p-6">
        <!-- Brand Container with Logo and Title - UPDATED LAYOUT -->
        <div class="flex flex-col md:flex-row items-center justify-between mb-6">
            <div class="brand-container flex flex-col items-center md:items-start mb-4 md:mb-0">
                <div class="logo-container mb-2">
                    <img src="resources/forte-arrivals.png" alt="Forte Logo" class="forte-logo w-48 md:w-64" 
                         onerror="this.src='https://placehold.co/200x120/f87171/ffffff.png?text=F'; this.onerror=null;">
                </div>
                <h1 class="title-glow text-2xl md:text-3xl">Card Previewer</h1>
            </div>

            <div class="controls-container w-full md:w-auto">
                <div id="filter-controls" class="flex flex-wrap items-center gap-y-2">
                    <h2 class="text-base font-semibold mr-2 text-gray-300 controls-label">Filters:</h2>
                    <div>
                        <label for="type-filter" class="filter-label">Type:</label>
                        <select id="type-filter" name="type-filter" class="filter-select">
                            <option value="all">All Types</option>
                        </select>
                    </div>
                    <div>
                        <label for="forte-filter" class="filter-label">Forte:</label>
                        <select id="forte-filter" name="forte-filter" class="filter-select">
                            <option value="all">All</option>
                            <option value="yes">Forte Only</option>
                            <option value="no">Non-Forte</option>
                        </select>
                    </div>
                    <div>
                        <label for="trainer-type-filter" class="filter-label">Trainer Type:</label>
                        <select id="trainer-type-filter" name="trainer-type-filter" class="filter-select">
                            <option value="all">All Trainers</option>
                        </select>
                    </div>
                    <div>
                        <label for="creator-filter" class="filter-label">Creator:</label>
                        <select id="creator-filter" name="creator-filter" class="filter-select">
                            <option value="all">All Creators</option>
                        </select>
                    </div>
               </div>
               <div id="size-controls" class="flex flex-wrap items-center gap-y-2 mt-2">
                   <h2 class="text-base font-semibold mr-2 text-gray-300 controls-label">Sizes:</h2>
                    <div class="size-control-group">
                        <label for="gallery-size-slider" class="size-label">Gallery:</label>
                        <input type="range" id="gallery-size-slider" name="gallery-size" min="0" max="2" step="1" value="1" class="size-slider w-20 align-middle">
                        <span id="gallery-size-display" class="size-display">M</span>
                   </div>
              </div>
            </div>
        </div>

        <div id="tab-container" class="flex flex-wrap gap-x-2 gap-y-2 items-center mb-4">
            <h2 class="text-base font-semibold mr-2 text-gray-300 controls-label">Set:</h2>
            <!-- Tabs generated here -->
        </div>

        <div class="border-t pt-4 border-black">
            <div id="item-gallery" class="mt-6 grid gap-4 items-start" role="grid">
                <!-- Cards rendered here -->
            </div>
            <p id="empty-folder-message" class="text-center mt-4 hidden">No images match the current filters.</p>
        </div>

         <footer class="footer">
             <img src="resources/tcg-pocket-logo.png" alt="" onerror="this.style.display='none'">
             This is a fan site for testing elements (image loading and previewing).
             <img src="resources/tcg-pocket-logo.png" alt="" onerror="this.style.display='none'">
        </footer>
    </div>

    <!-- Fancy Popup Lightbox -->
    <div id="fancy-lightbox" class="fancy-lightbox-overlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="fancy-lightbox-content">
            <!-- Header -->
            <div class="fancy-lightbox-header">
                <h2 class="fancy-lightbox-title">
                    <i class="fas fa-crown mr-2"></i>
                    <span id="card-title">Forte Card Viewer</span>
                </h2>
                <button id="fancy-lightbox-close" class="fancy-lightbox-close" aria-label="Close card viewer">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- Body (Left: Info, Right: Card) -->
            <div class="fancy-lightbox-body">
                <!-- Left: Card Info -->
                <div class="fancy-card-info">
                    <!-- Basic Info Section -->
                    <div class="info-section">
                        <div class="info-section-title">
                            <i class="fas fa-id-card"></i>
                            <span>Card Details</span>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Card Name</div>
                            <div id="info-card-name" class="info-value">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Set</div>
                            <div id="info-set-name" class="info-value">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Number</div>
                            <div id="info-card-number" class="info-value">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Dex Number</div>
                            <div id="info-dex-number" class="info-value">-</div>
                        </div>
                    </div>
                    
                    <!-- Type & Classification -->
                    <div class="info-section">
                        <div class="info-section-title">
                            <i class="fas fa-tag"></i>
                            <span>Classification</span>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Card Type</div>
                            <div id="info-card-type" class="info-value">-</div>
                            <!-- Dynamically add type badges here -->
                            <div id="info-type-badges" class="card-types">
                                <!-- Type badges go here -->
                            </div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Forte Status</div>
                            <div id="info-forte-status" class="info-value">-</div>
                        </div>
                        <div id="info-trainer-type-container" class="info-item" style="display: none;">
                            <div class="info-label">Trainer Type</div>
                            <div id="info-trainer-type" class="info-value">-</div>
                        </div>
                    </div>
                    
                    <!-- Creation Info -->
                    <div class="info-section">
                        <div class="info-section-title">
                            <i class="fas fa-user-edit"></i>
                            <span>Creation Info</span>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Creator</div>
                            <div id="info-creator" class="info-value">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">File Name</div>
                            <div id="info-file-name" class="info-value text-xs break-all opacity-50">-</div>
                        </div>
                        <!-- Like controls in lightbox -->
                        <div class="info-item">
                            <div class="info-label">Likes</div>
                            <div class="info-value flex items-center">
                                <span id="lb-like-count" class="mr-2">0</span>
                                <button id="lb-like-button" class="like-button" aria-label="Like this card">
                                    <i class="far fa-heart"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right: Card Display -->
                <div class="fancy-card-display">
                    <div id="fancy-spinner" class="spinner"></div>
                    
                    <!-- Card container with holo effect -->
                    <div id="fancy-holo-container" class="fancy-holo-container">
                        <div id="fancy-holo-inner" class="fancy-holo-inner">
                            <img id="fancy-card-image" class="fancy-card-image hidden" src="" alt="Card preview">
                        </div>
                    </div>
                    
                    <!-- Card view controls -->
                    <div id="fancy-card-controls" class="fancy-card-controls">
                        <button id="fancy-normal-view" class="fancy-control-button active" data-view="normal">
                            <i class="fas fa-image"></i>
                            <span>Normal</span>
                        </button>
                        <button id="fancy-textless-view" class="fancy-control-button" data-view="textless" disabled>
                            <i class="fas fa-square"></i>
                            <span>Textless</span>
                        </button>
                    </div>
                    
                    <!-- Navigation buttons -->
                    <div class="fancy-nav-controls">
                        <button id="fancy-prev-button" class="fancy-nav-button" aria-label="Previous card">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <button id="fancy-next-button" class="fancy-nav-button" aria-label="Next card">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                    
                    <!-- Zoom controls -->
                    <div class="fancy-zoom-controls">
                        <button id="fancy-zoom-in" class="fancy-zoom-button" aria-label="Zoom in">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <button id="fancy-zoom-reset" class="fancy-zoom-button" aria-label="Reset zoom">
                            <i class="fas fa-expand"></i>
                        </button>
                        <button id="fancy-zoom-out" class="fancy-zoom-button" aria-label="Zoom out">
                            <i class="fas fa-search-minus"></i>
                        </button>
                    </div>
                    
                    <!-- Keyboard controls hint -->
                    <div class="keyboard-hint">
                        <span><kbd>←</kbd> <kbd>→</kbd> Navigate</span>
                        <span><kbd>+</kbd> <kbd>-</kbd> Zoom</span>
                        <span><kbd>Esc</kbd> Close</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="audio-prompt" style="display: block;">Click anywhere to enable audio</div>

    <div id="audio-control-container" style="display: none;">
         <span id="song-name"></span>
         <button id="play-pause-button" class="audio-button" aria-label="Play/Pause"><i class="fas fa-play"></i></button>
         <button id="next-song-button" class="audio-button" aria-label="Next Song"><i class="fas fa-forward-step"></i></button>
         <div id="mute-button" class="audio-button" aria-label="Mute/Unmute">
              <i class="fas fa-volume-high"></i>
              <div id="volume-container">
                   <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.6">
              </div>
         </div>
    </div>

    <style>
        /* Additional styles for the likes feature */
        .like-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(220, 38, 38, 0.1);
            color: #dc2626;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .like-button:hover {
            background: rgba(220, 38, 38, 0.2);
            transform: scale(1.1);
        }
        
        .like-button.liked i {
            font-weight: 900;
            animation: heartBeat 0.5s;
        }
        
        .thumbnail {
            position: relative;
        }
        
        .thumbnail-like-container {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 8px;
            border-radius: 12px;
            color: white;
            z-index: 5;
        }
        
        .thumbnail-like-count {
            font-size: 0.8rem;
            margin-right: 4px;
        }
        
        .thumbnail-like-button {
            background: none;
            border: none;
            color: #dc2626;
            cursor: pointer;
            padding: 2px;
            transition: transform 0.2s ease;
        }
        
        .thumbnail-like-button:hover {
            transform: scale(1.2);
        }
        
        @keyframes heartBeat {
            0% { transform: scale(1); }
            14% { transform: scale(1.3); }
            28% { transform: scale(1); }
            42% { transform: scale(1.3); }
            70% { transform: scale(1); }
        }
    </style>

    <script>
        // --- Configuration ---
        const placeholderUrl = "https://placehold.co/100x80/cccccc/ffffff.png?text=Error";
        const mainPlaceholderUrl = "https://placehold.co/600x400/cccccc/ffffff.png?text=Loading...";
        const CLICK_EFFECT_DURATION_MS = 400;
        const RESOURCE_FOLDER = 'resources';
        const BLANK_SUFFIX = '-BL-';
        const SIZE_MAP = ['S', 'M', 'L'];
        const GALLERY_SIZE_CLASSES = { 0: 'gallery-size-s', 1: 'gallery-size-m', 2: 'gallery-size-l' };
        const DEFAULT_GALLERY_SIZE_INDEX = 1; // Medium
        const GALLERY_SIZE_KEY = 'galleryImageSizePref'; // localStorage key
        const PRELOAD_NEXT_PREV = true; // Preload next and previous images

        // --- Elements ---
        const pageLoadingOverlay = document.getElementById('page-loading-overlay');
        const itemGallery = document.getElementById('item-gallery');
        const tabContainer = document.getElementById('tab-container');
        const typeFilterSelect = document.getElementById('type-filter');
        const forteFilterSelect = document.getElementById('forte-filter');
        const trainerTypeFilterSelect = document.getElementById('trainer-type-filter');
        const creatorFilterSelect = document.getElementById('creator-filter');
        const emptyFolderMessage = document.getElementById('empty-folder-message');
        const gallerySizeSlider = document.getElementById('gallery-size-slider');
        const gallerySizeDisplay = document.getElementById('gallery-size-display');
        
        // --- Fancy Lightbox Elements ---
        const fancyLightbox = document.getElementById('fancy-lightbox');
        const fancyLightboxContent = fancyLightbox.querySelector('.fancy-lightbox-content');
        const fancyLightboxClose = document.getElementById('fancy-lightbox-close');
        const fancyCardTitle = document.getElementById('card-title');
        const fancySpinner = document.getElementById('fancy-spinner');
        const fancyHoloContainer = document.getElementById('fancy-holo-container');
        const fancyHoloInner = document.getElementById('fancy-holo-inner');
        const fancyCardImage = document.getElementById('fancy-card-image');
        const fancyPrevButton = document.getElementById('fancy-prev-button');
        const fancyNextButton = document.getElementById('fancy-next-button');
        const fancyNormalView = document.getElementById('fancy-normal-view');
        const fancyTextlessView = document.getElementById('fancy-textless-view');
        const fancyZoomIn = document.getElementById('fancy-zoom-in');
        const fancyZoomOut = document.getElementById('fancy-zoom-out');
        const fancyZoomReset = document.getElementById('fancy-zoom-reset');
        
        // --- Card Info Elements ---
        const infoCardName = document.getElementById('info-card-name');
        const infoSetName = document.getElementById('info-set-name');
        const infoCardNumber = document.getElementById('info-card-number');
        const infoDexNumber = document.getElementById('info-dex-number');
        const infoCardType = document.getElementById('info-card-type');
        const infoTypeBadges = document.getElementById('info-type-badges');
        const infoForteStatus = document.getElementById('info-forte-status');
        const infoTrainerTypeContainer = document.getElementById('info-trainer-type-container');
        const infoTrainerType = document.getElementById('info-trainer-type');
        const infoCreator = document.getElementById('info-creator');
        const infoFileName = document.getElementById('info-file-name');
        const lbLikeButton = document.getElementById('lb-like-button');
        const lbLikeCount = document.getElementById('lb-like-count');

        // --- State ---
        let currentSetTab = 'all';
        let currentImageFiles = []; // Images for lightbox sequence (filtered, non-blank)
        let currentImageIndex = -1;
        let focusableElements = [];
        let currentFocusIndex = 0;
        let activeHoloTimeout = null;
        let currentlyDisplayedImages = []; // FULL filtered list (incl. blanks)
        let currentTypeFilter = 'all';
        let currentForteFilter = 'all';
        let currentTrainerTypeFilter = 'all';
        let currentCreatorFilter = 'all';
        let baseImageSet = []; // All images for the current SET tab
        let currentGallerySizeIndex = DEFAULT_GALLERY_SIZE_INDEX;
        let lastScrollY = 0;
        let allCreators = new Set();
        let currentFancyCardImage = null;
        let fancyHasBlankVersion = false;
        let fancyBlankVersionPath = '';
        let fancyNormalVersionPath = '';
        let fancyActiveHoloTimeout = null;
        let isZoomed = false;
        let imageCache = new Map(); // Cache for preloaded images
        let intersectionObserver; // For lazy loading and in-view effects
        let backgroundAnimationPaused = false; // Track background animation state

        // --- Data loaded from image_data.js ---
        let rootImageStructure = null;
        let filterConfig = null;

        // --- Cache and Preload Utilities ---
        /** Preload an image and store in cache */
        function preloadImage(src) {
            if (!src || imageCache.has(src)) return Promise.resolve();
            
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache.set(src, img);
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn(`Failed to preload: ${src}`);
                    reject(new Error(`Failed to preload: ${src}`));
                };
                img.src = src;
            });
        }
        
        /** Preload next and previous images */
        function preloadAdjacentImages() {
            if (!PRELOAD_NEXT_PREV || !currentImageFiles || currentImageIndex < 0) return;
            
            // Preload next image if available
            if (currentImageIndex < currentImageFiles.length - 1) {
                const nextImage = currentImageFiles[currentImageIndex + 1];
                preloadImage(encodeImagePath(nextImage.path))
                    .catch(err => console.log('Non-critical preload error:', err));
            }
            
            // Preload previous image if available
            if (currentImageIndex > 0) {
                const prevImage = currentImageFiles[currentImageIndex - 1];
                preloadImage(encodeImagePath(prevImage.path))
                    .catch(err => console.log('Non-critical preload error:', err));
            }
        }

        // --- Utility Functions ---
        /** Gets the extension from a filename */
        function getExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            if (lastDot === -1 || lastDot === 0 || lastDot === filename.length - 1) return ''; // Handle cases like ".bashrc" or "file."
            return filename.substring(lastDot);
        }

        /** Recursively collects all image file objects from a node */
        function getAllImageFilesRecursive(node) {
            let files = [];
            if (!node || !node.children) return files;
            node.children.forEach(child => {
                if (child.type === 'file') {
                    if(child.creator && !allCreators.has(child.creator)) allCreators.add(child.creator);
                    files.push(child);
                } else if (child.type === 'folder') {
                    files = files.concat(getAllImageFilesRecursive(child));
                }
            });
            return files;
        }

        /** Opens the Fancy Lightbox */
        function openFancyLightbox(imageObject) {
            if (!imageObject) { console.error("Invalid image object passed to openFancyLightbox"); return; }
            
            // Store current scroll position and current card
            lastScrollY = window.scrollY;
            currentFancyCardImage = imageObject;
            
            // Set up the navigation sequence (filtered, non-blank images)
            currentImageFiles = currentlyDisplayedImages.filter(img => !img.isBlank);
            currentImageIndex = currentImageFiles.findIndex(img => img.path === imageObject.path);
            if (currentImageIndex === -1) {
                console.warn("Fallback: Clicked image not in displayed non-blanks. Using base set for nav.");
                currentImageFiles = baseImageSet.filter(img => !img.isBlank);
                currentImageIndex = currentImageFiles.findIndex(img => img.path === imageObject.path);
                if (currentImageIndex === -1) { 
                    currentImageFiles = [imageObject]; 
                    currentImageIndex = 0; 
                }
            }
            
            // Update the card title
            fancyCardTitle.textContent = imageObject.cardName || "Card Preview";
            
            // Update card info panel
            updateCardInfo(imageObject);
            
            // Check for blank version
            checkBlankVersion(imageObject);
            
            // Reset zoom state
            resetZoom();
            
            // Load the image
            loadFancyCardImage(imageObject.path);
            
            // Preload adjacent images
            preloadAdjacentImages();
            
            // Update navigation controls
            updateFancyNavigation();
            
            // Show the lightbox
            fancyLightbox.classList.add('visible');
            fancyLightbox.setAttribute('aria-hidden', 'false');
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
            
            // Focus the close button (for accessibility)
            setTimeout(() => fancyLightboxClose.focus(), 100);
            
            // Highlight the selected thumbnail in the gallery
            highlightThumbnail(imageObject.path);
            
            // Initialize holo effect
            applyFancyHoloListeners('#fancy-holo-container');
            
            // Pause background animation
            pauseBackgroundAnimation(true);
            
            // Update like button and count in lightbox
            updateLightboxLikeStatus(imageObject.path);
        }
        
        /** Pause or resume the background animation */
        function pauseBackgroundAnimation(pause) {
            backgroundAnimationPaused = pause;
            // The background.js script will check this variable
            if (typeof window.setBackgroundPaused === 'function') {
                window.setBackgroundPaused(pause);
            }
        }
        
        /** Load an image into the fancy lightbox */
        function loadFancyCardImage(path) {
            fancySpinner.classList.remove('hidden');
            fancyCardImage.classList.add('hidden');
            fancyHoloInner.classList.remove('holo-active');
            
            // Properly encode the image path
            const encodedPath = encodeImagePath(path);
            console.log(`Loading image: ${encodedPath}`);
            
            // Check if in cache first
            if (imageCache.has(encodedPath)) {
                console.log(`Loading from cache: ${encodedPath}`);
                fancyCardImage.src = encodedPath;
                fancyCardImage.alt = `Card preview: ${path.split('/').pop()}`;
                fancySpinner.classList.add('hidden');
                fancyCardImage.classList.remove('hidden');
                fancyCardImage.classList.add('loaded');
                return;
            }
            
            // Set up image load handler
            fancyCardImage.onload = () => {
                fancySpinner.classList.add('hidden');
                fancyCardImage.classList.remove('hidden');
                fancyCardImage.classList.add('loaded');
                console.log(`Fancy image loaded: ${path}`);
                
                // Store in cache
                imageCache.set(encodedPath, fancyCardImage.cloneNode(false));
            };
            
            // Set up error handler
            fancyCardImage.onerror = () => {
                console.error(`Failed to load fancy image: ${path}`);
                fancySpinner.classList.add('hidden');
                fancyCardImage.classList.remove('hidden');
                fancyCardImage.src = mainPlaceholderUrl;
                fancyCardImage.alt = `Error loading image`;
            };
            
            // Load the image
            fancyCardImage.src = encodedPath;
            fancyCardImage.alt = `Card preview: ${path.split('/').pop()}`;
        }
        
        /** Update the card info panel with card details */
        function updateCardInfo(card) {
            if (!card) return;
            
            // Update basic card info
            infoCardName.textContent = card.cardName || 'Unknown';
            infoSetName.textContent = card.setName || 'Unknown Set';
            infoCardNumber.textContent = card.setNumber || 'N/A';
            infoDexNumber.textContent = card.dexNumber || 'N/A';
            infoCardType.textContent = card.cardType || 'Unknown';
            infoFileName.textContent = card.name || 'Unknown';
            
            // Update Forte status with badge if it's a Forte card
            if (card.isForte) {
                infoForteStatus.innerHTML = '<div class="forte-badge"><i class="fas fa-crown"></i> Forte</div>';
            } else {
                infoForteStatus.textContent = 'No';
            }
            
            // Update creator info
            infoCreator.textContent = card.creator || 'Unknown';
            
            // Show/hide trainer type info based on card type
            if (card.cardType === 'Trainer' && card.trainerType) {
                infoTrainerTypeContainer.style.display = 'block';
                infoTrainerType.textContent = card.trainerType;
            } else {
                infoTrainerTypeContainer.style.display = 'none';
            }
            
            // Clear and update type badges
            infoTypeBadges.innerHTML = '';
            if (card.types && card.types.length > 0) {
                card.types.forEach(type => {
                    const badge = document.createElement('span');
                    badge.className = `card-type-badge type-${type}`;
                    badge.innerHTML = `<i class="fas fa-fire-alt"></i> ${type}`;
                    infoTypeBadges.appendChild(badge);
                });
            } else if (card.cardType === 'Trainer') {
                const badge = document.createElement('span');
                badge.className = 'card-type-badge';
                badge.innerHTML = `<i class="fas fa-user"></i> Trainer`;
                infoTypeBadges.appendChild(badge);
            }
        }
        
        /** Check if a blank version of the card exists */
        function checkBlankVersion(card) {
            if (!card) return;
            
            const ext = getExtension(card.name);
            const baseFilename = card.name.replace(BLANK_SUFFIX + ext, '').replace(ext, '');
            const potentialBlankPath = card.path.replace(card.name, `${baseFilename}${BLANK_SUFFIX}${ext}`);
            const potentialNormalPath = card.path.replace(card.name, `${baseFilename}${ext}`);
            
            // Check if this is a blank version by looking for -BL- in the name
            const isBlank = card.name.includes(BLANK_SUFFIX);
            
            if (isBlank) {
                fancyNormalVersionPath = potentialNormalPath;
                fancyBlankVersionPath = card.path;
            } else {
                fancyNormalVersionPath = card.path;
                fancyBlankVersionPath = potentialBlankPath;
            }
            
            // Look for a matching card with the same name but blank/normal version
            const allImagesFull = getAllImageFilesRecursive(rootImageStructure);
            const matchingCard = allImagesFull.find(img => {
                return isBlank ? 
                    img.path === potentialNormalPath :
                    img.path === potentialBlankPath;
            });
            
            fancyHasBlankVersion = !!matchingCard;
            
            // Enable/disable textless button
            fancyTextlessView.disabled = !fancyHasBlankVersion;
            
            // Set active button based on current view
            fancyNormalView.classList.toggle('active', !isBlank);
            fancyTextlessView.classList.toggle('active', isBlank);
        }
        
        /** Update fancy lightbox navigation controls */
        function updateFancyNavigation() {
            fancyPrevButton.disabled = currentImageIndex <= 0;
            fancyNextButton.disabled = currentImageIndex >= currentImageFiles.length - 1;
        }
        
        /** Navigate to the previous image */
        function showPreviousCard() {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                const prevImage = currentImageFiles[currentImageIndex];
                loadFancyCardImage(prevImage.path);
                updateCardInfo(prevImage);
                checkBlankVersion(prevImage);
                updateFancyNavigation();
                highlightThumbnail(prevImage.path);
                resetZoom();
                
                // Update like button and count in lightbox
                updateLightboxLikeStatus(prevImage.path);
                
                // Preload adjacent images
                preloadAdjacentImages();
            }
        }
        
        /** Navigate to the next image */
        function showNextCard() {
            if (currentImageIndex < currentImageFiles.length - 1) {
                currentImageIndex++;
                const nextImage = currentImageFiles[currentImageIndex];
                loadFancyCardImage(nextImage.path);
                updateCardInfo(nextImage);
                checkBlankVersion(nextImage);
                updateFancyNavigation();
                highlightThumbnail(nextImage.path);
                resetZoom();
                
                // Update like button and count in lightbox
                updateLightboxLikeStatus(nextImage.path);
                
                // Preload adjacent images
                preloadAdjacentImages();
            }
        }
        
        /** Switch between normal and textless views */
        function switchCardView(view) {
            if (!fancyHasBlankVersion) return;
            
            if (view === 'normal' && fancyNormalVersionPath) {
                loadFancyCardImage(fancyNormalVersionPath);
                fancyNormalView.classList.add('active');
                fancyTextlessView.classList.remove('active');
            } else if (view === 'textless' && fancyBlankVersionPath) {
                loadFancyCardImage(fancyBlankVersionPath);
                fancyTextlessView.classList.add('active');
                fancyNormalView.classList.remove('active');
            }
        }
        
        /** Close the fancy lightbox */
        function closeFancyLightbox() {
            fancyLightbox.classList.remove('visible');
            fancyLightbox.setAttribute('aria-hidden', 'true');
            
            // Reset state
            resetFancyHoloEffect();
            resetZoom();
            document.body.style.overflow = '';
            
            // Resume background animation
            pauseBackgroundAnimation(false);
            
            // Restore scroll position
            window.scrollTo({ top: lastScrollY, behavior: 'instant' });
            
            // Find and focus the thumbnail that was clicked
            const focusedImageObject = currentImageFiles[currentImageIndex];
            const opener = focusedImageObject ? 
                itemGallery.querySelector(`.thumbnail[data-path='${focusedImageObject.path}']`) : 
                null;
                
            unhighlightAllThumbnails();
            
            // Focus back on the thumbnail
            setTimeout(() => {
                if (opener) { 
                    opener.focus({ preventScroll: true }); 
                } else if (focusableElements.length > 0) { 
                    focusableElements[0].focus({ preventScroll: true }); 
                }
            }, 10);
        }
        
        /** Zoom operations */
        function zoomIn() {
            fancyHoloInner.classList.remove('zoom-out');
            fancyHoloInner.classList.add('zoom-in');
            fancyHoloContainer.classList.add('zoomed');
            isZoomed = true;
        }
        
        function zoomOut() {
            fancyHoloInner.classList.remove('zoom-in');
            fancyHoloInner.classList.add('zoom-out');
            isZoomed = true;
        }
        
        function resetZoom() {
            fancyHoloInner.classList.remove('zoom-in', 'zoom-out');
            fancyHoloContainer.classList.remove('zoomed');
            isZoomed = false;
        }

        /** Highlights the thumbnail */
        function highlightThumbnail(imagePath) {
             unhighlightAllThumbnails();
             const thumbContainer = itemGallery.querySelector(`.thumbnail[data-path='${imagePath}']`);
             if (thumbContainer) { thumbContainer.classList.add('selected-inline'); }
        }
        
        /** Removes highlight from all thumbnails */
        function unhighlightAllThumbnails() { 
            itemGallery.querySelectorAll('.thumbnail.selected-inline').forEach(el => { 
                el.classList.remove('selected-inline'); 
            }); 
        }
        
        /** Properly encode image paths to handle special characters */
        function encodeImagePath(path) {
            if (!path) return '';
            
            // Split the path by segments and encode each part separately
            // Keep the directory separators intact
            return path.split('/').map(segment => encodeURIComponent(segment)).join('/');
        }

        /** Set up intersection observer for lazy loading and in-view effects */
        function setupIntersectionObserver() {
            if ('IntersectionObserver' in window) {
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const thumbnail = entry.target;
                        
                        // Apply or remove the 'in-view' class
                        if (entry.isIntersecting) {
                            thumbnail.classList.add('in-view');
                            
                            // Force load image if it's in view
                            const img = thumbnail.querySelector('img');
                            if (img && !img.classList.contains('loaded') && img.dataset.src) {
                                img.src = img.dataset.src;
                                delete img.dataset.src;
                            }
                        } else {
                            thumbnail.classList.remove('in-view');
                            resetHoloEffect(thumbnail, true);
                        }
                    });
                }, {
                    root: null, // viewport
                    rootMargin: '100px', // load a bit before they come into view
                    threshold: 0.1 // trigger when 10% visible
                });
            }
        }

        /** Update like status in the lightbox */
        function updateLightboxLikeStatus(imagePath) {
            if (!lbLikeButton || !lbLikeCount) return;
            
            // Get the like count and status for this card
            const likeData = getLikeData(imagePath);
            lbLikeCount.textContent = likeData.count;
            
            // Update button style
            if (likeData.liked) {
                lbLikeButton.classList.add('liked');
                lbLikeButton.querySelector('i').classList.remove('far');
                lbLikeButton.querySelector('i').classList.add('fas');
            } else {
                lbLikeButton.classList.remove('liked');
                lbLikeButton.querySelector('i').classList.remove('fas');
                lbLikeButton.querySelector('i').classList.add('far');
            }
            
            // Add click handler
            lbLikeButton.onclick = function() {
                toggleLike(imagePath);
                updateLightboxLikeStatus(imagePath);
                updateAllThumbnailLikes();
            };
        }

        /** Renders the gallery based on a list of image file objects */
        function renderGalleryView(imagesToDisplay) {
            console.log(`[renderGalleryView] Rendering gallery with ${imagesToDisplay?.length || 0} images.`);
            
            // Disconnect observer from old elements
            if (intersectionObserver) {
                intersectionObserver.disconnect();
            }
            
            itemGallery.innerHTML = '';
            focusableElements = [];
            currentlyDisplayedImages = imagesToDisplay || []; // Full list for this view

            // Filter out blanks for initial gallery display
            const nonBlankImagesToDisplay = currentlyDisplayedImages.filter(img => !img.isBlank);
            currentImageFiles = nonBlankImagesToDisplay; // Set lightbox sequence to non-blanks

            let hasContent = nonBlankImagesToDisplay.length > 0;

            console.log(`[renderGalleryView] Displaying ${nonBlankImagesToDisplay.length} non-blank images.`);

            nonBlankImagesToDisplay.forEach(image => {
                const thumbnailContainer = document.createElement('div');
                thumbnailContainer.className = 'thumbnail';
                thumbnailContainer.setAttribute('tabindex', '0'); 
                thumbnailContainer.setAttribute('role', 'button');
                thumbnailContainer.dataset.path = image.path;
                thumbnailContainer.dataset.object = JSON.stringify(image);
                thumbnailContainer.setAttribute('aria-label', `Image: ${image.name}`);

                const img = document.createElement('img');
                
                // Lazy loading - store path in data-src
                const encodedPath = encodeImagePath(image.path);
                img.dataset.src = encodedPath;
                img.alt = `Thumbnail ${image.name}`;
                img.className = 'w-full h-auto block pointer-events-none';
                
                // Image load handling
                img.onload = () => {
                    img.classList.add('loaded');
                    if (img.naturalWidth && img.naturalHeight) {
                        const aspectRatio = img.naturalWidth / img.naturalHeight;
                        const borderRadiusMultiplier = Math.min(Math.max(aspectRatio, 0.5), 1.5);
                        thumbnailContainer.style.setProperty('--image-aspect-ratio', aspectRatio);
                        thumbnailContainer.style.borderRadius = `${5 * borderRadiusMultiplier}% / ${3.5 / borderRadiusMultiplier}%`;
                    } else { 
                        thumbnailContainer.style.borderRadius = `${5 * 0.75}% / ${3.5 / 0.75}%`; 
                    }
                };
                
                img.onerror = function() {
                    console.error(`Failed to load image: ${image.path}, Encoded as: ${encodedPath}`);
                    const container = this.closest('.thumbnail');
                    if (container) {
                        container.innerHTML = `<div class="flex items-center justify-center bg-gray-600 aspect-video text-gray-400 rounded-md"><i class="fas fa-image fa-lg" title="Error loading ${image.name}"></i></div>`;
                        container.style.cursor = 'not-allowed';
                        container.removeAttribute('tabindex'); 
                        container.removeAttribute('role');
                        container.removeAttribute('data-path'); 
                        container.style.pointerEvents = 'none';
                        console.warn(`Thumbnail failed to load: ${image.path}`);
                        focusableElements = Array.from(itemGallery.querySelectorAll('.thumbnail[tabindex="0"]'));
                    }
                };

                const activateThumbnail = (eventSourceElement) => {
                    const internalImg = eventSourceElement.querySelector('img');
                    const imgDataStr = eventSourceElement.dataset.object;
                    if (internalImg && !eventSourceElement.querySelector('.bg-gray-600') && 
                        !eventSourceElement.classList.contains('holo-click-active') && imgDataStr) {
                        
                        eventSourceElement.classList.add('holo-click-active');
                        resetHoloEffect(eventSourceElement, false);
                        
                        setTimeout(() => {
                            eventSourceElement.classList.remove('holo-click-active');
                            openFancyLightbox(JSON.parse(imgDataStr));
                        }, CLICK_EFFECT_DURATION_MS);
                    }
                };
                
                thumbnailContainer.addEventListener('click', () => activateThumbnail(thumbnailContainer));
                thumbnailContainer.addEventListener('keydown', (e) => { 
                    if (e.key === 'Enter' || e.key === ' ') { 
                        e.preventDefault(); 
                        activateThumbnail(thumbnailContainer); 
                    } 
                });

                // Add like container to thumbnail
                const likeData = window.getLikeData ? window.getLikeData(image.path) : { count: 0, liked: false };
                const likeContainer = document.createElement('div');
                likeContainer.className = 'thumbnail-like-container';
                likeContainer.innerHTML = `
                    <span class="thumbnail-like-count">${likeData.count}</span>
                    <button class="thumbnail-like-button" aria-label="Like this card">
                        <i class="${likeData.liked ? 'fas' : 'far'} fa-heart"></i>
                    </button>
                `;
                
                // Like button click handler
                const likeButton = likeContainer.querySelector('.thumbnail-like-button');
                likeButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent opening the lightbox
                    if (window.toggleLike) window.toggleLike(image.path);
                    updateAllThumbnailLikes();
                    // If the lightbox is open and showing this card, update it too
                    if (fancyLightbox.classList.contains('visible') && currentFancyCardImage && currentFancyCardImage.path === image.path) {
                        updateLightboxLikeStatus(image.path);
                    }
                });

                thumbnailContainer.appendChild(img);
                thumbnailContainer.appendChild(likeContainer);
                itemGallery.appendChild(thumbnailContainer);
                focusableElements.push(thumbnailContainer);
                
                // Observe this thumbnail for intersection
                if (intersectionObserver) {
                    intersectionObserver.observe(thumbnailContainer);
                }
            });

            emptyFolderMessage.classList.toggle('hidden', hasContent);
            currentFocusIndex = 0;
            
            // Initial load for visible thumbnails
            if (!intersectionObserver) {
                // No IntersectionObserver support, load all visible images immediately
                itemGallery.querySelectorAll('.thumbnail').forEach(thumbnail => {
                    thumbnail.classList.add('in-view');
                    const img = thumbnail.querySelector('img');
                    if (img && img.dataset.src) {
                        img.src = img.dataset.src;
                        delete img.dataset.src;
                    }
                });
            }
        }

        /** Update all thumbnail like counters and icons */
        function updateAllThumbnailLikes() {
            itemGallery.querySelectorAll('.thumbnail').forEach(thumbnail => {
                const path = thumbnail.dataset.path;
                if (!path) return;
                
                const likeContainer = thumbnail.querySelector('.thumbnail-like-container');
                if (!likeContainer) return;
                
                const likeCount = likeContainer.querySelector('.thumbnail-like-count');
                const likeButton = likeContainer.querySelector('.thumbnail-like-button i');
                
                const likeData = getLikeData(path);
                if (likeCount) likeCount.textContent = likeData.count;
                
                if (likeButton) {
                    if (likeData.liked) {
                        likeButton.classList.remove('far');
                        likeButton.classList.add('fas');
                    } else {
                        likeButton.classList.remove('fas');
                        likeButton.classList.add('far');
                    }
                }
            });
        }

        /** Applies current filters and triggers rendering */
        function applyFiltersAndRender() {
            console.log(`[applyFiltersAndRender] Applying filters: Type='${currentTypeFilter}', Forte='${currentForteFilter}', Trainer='${currentTrainerTypeFilter}', Creator='${currentCreatorFilter}'`);
            console.log(`[applyFiltersAndRender] Base image set size (for current tab): ${baseImageSet.length}`);
            let filteredImages = [...baseImageSet];

            if (currentTypeFilter !== 'all') { 
                filteredImages = filteredImages.filter(img => img.cardType === currentTypeFilter); 
            }
            
            if (currentForteFilter === 'yes') { 
                filteredImages = filteredImages.filter(img => img.isForte === true); 
            } else if (currentForteFilter === 'no') { 
                filteredImages = filteredImages.filter(img => img.isForte === false); 
            }
            
            if (currentTrainerTypeFilter !== 'all' && (currentTypeFilter === 'Trainer' || currentTypeFilter === 'all')) { 
                filteredImages = filteredImages.filter(img => img.trainerType === currentTrainerTypeFilter); 
            }
            
            if (currentCreatorFilter !== 'all') { 
                filteredImages = filteredImages.filter(img => img.creator === currentCreatorFilter); 
            }

            currentlyDisplayedImages = filteredImages; // Store the FULL filtered list (includes blanks)
            console.log(`[applyFiltersAndRender] Total filtered images (incl. blanks): ${currentlyDisplayedImages.length}`);

            renderGalleryView(currentlyDisplayedImages); // Render ALL filtered images
        }

        /** Populates filter dropdowns */
        function populateFilters() {
            if (!filterConfig || !typeFilterSelect || !trainerTypeFilterSelect || !creatorFilterSelect || !forteFilterSelect) {
                console.error("[populateFilters] Cannot populate: Missing config or select elements."); 
                return;
            }
            
            console.log("[populateFilters] Config:", filterConfig);

            // Type Filter
            while (typeFilterSelect.options.length > 1) { typeFilterSelect.remove(1); }
            (filterConfig.typeOrder || []).forEach(type => { 
                const option = document.createElement('option'); 
                option.value = type; 
                option.textContent = type; 
                typeFilterSelect.appendChild(option); 
            });

            // Trainer Type Filter
            while (trainerTypeFilterSelect.options.length > 1) { trainerTypeFilterSelect.remove(1); }
            (filterConfig.trainerTypeOrder || []).forEach(type => { 
                const option = document.createElement('option'); 
                option.value = type; 
                option.textContent = type; 
                trainerTypeFilterSelect.appendChild(option); 
            });

            // Creator Filter
            while (creatorFilterSelect.options.length > 1) { creatorFilterSelect.remove(1); }
            const sortedCreators = Array.from(allCreators).sort((a, b) => a.localeCompare(b));
            console.log("[populateFilters] Found creators:", sortedCreators);
            sortedCreators.forEach(creator => { 
                if (creator) { 
                    const option = document.createElement('option'); 
                    option.value = creator; 
                    option.textContent = creator; 
                    creatorFilterSelect.appendChild(option); 
                } 
            });
        }

        /** Renders the navigation tabs based on Sets */
        function renderTabs() {
            if (!tabContainer || !rootImageStructure || !filterConfig || !filterConfig.setOrder || !filterConfig.setColors) {
                console.error("[renderTabs] Missing elements or config.");
                const label = tabContainer.querySelector('h2'); 
                tabContainer.innerHTML = ''; 
                if (label) tabContainer.appendChild(label); 
                return;
            }
            
            const label = tabContainer.querySelector('h2'); 
            tabContainer.innerHTML = ''; 
            if (label) tabContainer.appendChild(label);

            const allImagesForSets = getAllImageFilesRecursive(rootImageStructure);
            const availableSetNames = new Set(allImagesForSets.map(img => img.setName).filter(name => name));
            console.log("[renderTabs] Available set names:", availableSetNames);

            // --- Create "All" tab ---
            const allTab = document.createElement('button');
            allTab.className = 'tab active'; 
            allTab.dataset.setName = 'all';
            const allColor = filterConfig.setColors['all'] || filterConfig.setColors['default'] || '#6B7280';
            allTab.style.setProperty('--tab-active-border-color', allColor);
            allTab.style.setProperty('--tab-active-bg-color', hexToRgba(allColor, 0.3));
            allTab.style.setProperty('--tab-active-text-color', lightenHexColor(allColor, 0.8));
            const allTextSpan = document.createElement('span'); 
            allTextSpan.textContent = 'All'; 
            allTab.appendChild(allTextSpan);
            tabContainer.appendChild(allTab);

            // --- Create Tabs based on setOrder ---
            filterConfig.setOrder.forEach(setName => {
                if (availableSetNames.has(setName) || setName === "Other") {
                    const setTab = document.createElement('button');
                    setTab.className = 'tab'; 
                    setTab.dataset.setName = setName;
                    const tabColor = filterConfig.setColors[setName] || filterConfig.setColors['default'] || '#6B7280';
                    setTab.style.setProperty('--tab-active-border-color', tabColor);
                    setTab.style.setProperty('--tab-active-bg-color', hexToRgba(tabColor, 0.3));
                    setTab.style.setProperty('--tab-active-text-color', lightenHexColor(tabColor, 0.8));
                    const textSpan = document.createElement('span'); 
                    textSpan.textContent = setName; 
                    setTab.appendChild(textSpan);
                    tabContainer.appendChild(setTab);
                } else { 
                    console.log(`[renderTabs] Skipping tab for set "${setName}" as no images found.`); 
                }
            });

            // --- Add event listener ---
            if (!tabContainer.dataset.listenerAttached) {
                tabContainer.addEventListener('click', (e) => {
                    const clickedTab = e.target.closest('.tab');
                    if (clickedTab && !clickedTab.classList.contains('active')) {
                        const setName = clickedTab.dataset.setName;
                        tabContainer.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                        clickedTab.classList.add('active');
                        currentSetTab = setName;

                        const allImagesFull = getAllImageFilesRecursive(rootImageStructure);
                        if (setName === 'all') {
                            baseImageSet = allImagesFull.filter(img => img.setName !== "Misc"); // Exclude MISC
                        } else {
                            baseImageSet = allImagesFull.filter(img => img.setName === setName);
                        }
                        console.log(`[Tab Click] Set base set to '${setName}':`, baseImageSet.length);
                        applyFiltersAndRender();
                    }
                });
                tabContainer.dataset.listenerAttached = 'true';
            }
        }

        /** Displays an error message */
        function displayError(message) {
            itemGallery.innerHTML = `<p class="text-red-500 col-span-full p-4 bg-red-100 border border-red-400 rounded">${message}</p>`;
            emptyFolderMessage.classList.add('hidden');
        }
        
        /** Handles keyboard navigation within the gallery */
        function handleGalleryKeyDown(e) {
            if (focusableElements.length === 0 || fancyLightbox.classList.contains('visible')) return;
            const gridElement = document.getElementById('item-gallery');
            const gridStyle = window.getComputedStyle(gridElement);
            const gridCols = gridStyle.getPropertyValue('grid-template-columns').split(' ').length;
            let nextFocusIndex = currentFocusIndex;
            switch (e.key) {
                case 'ArrowRight': nextFocusIndex = (currentFocusIndex + 1) % focusableElements.length; break;
                case 'ArrowLeft': nextFocusIndex = (currentFocusIndex - 1 + focusableElements.length) % focusableElements.length; break;
                case 'ArrowDown': nextFocusIndex = Math.min(currentFocusIndex + gridCols, focusableElements.length - 1); break;
                case 'ArrowUp': nextFocusIndex = Math.max(currentFocusIndex - gridCols, 0); break;
                case 'Home': nextFocusIndex = 0; break;
                case 'End': nextFocusIndex = focusableElements.length - 1; break;
                default: return;
            }
            if (nextFocusIndex !== currentFocusIndex && nextFocusIndex < focusableElements.length) {
                e.preventDefault();
                currentFocusIndex = nextFocusIndex;
                if(focusableElements[currentFocusIndex]) { focusableElements[currentFocusIndex].focus(); }
            }
        }
        
        /** Handles keyboard events when the lightbox is open */
        function handleFancyLightboxKeyDown(e) {
            if (!fancyLightbox.classList.contains('visible')) return;
            
            switch (e.key) {
                case 'Escape':
                    closeFancyLightbox();
                    break;
                case 'ArrowLeft':
                    if (!fancyPrevButton.disabled) showPreviousCard();
                    break;
                case 'ArrowRight':
                    if (!fancyNextButton.disabled) showNextCard();
                    break;
                case '+':
                case '=':
                    zoomIn();
                    break;
                case '-':
                case '_':
                    zoomOut();
                    break;
                case '0':
                    resetZoom();
                    break;
                case ' ':
                    // Toggle textless if available
                    if (!fancyTextlessView.disabled) {
                        if (fancyNormalView.classList.contains('active')) {
                            switchCardView('textless');
                        } else {
                            switchCardView('normal');
                        }
                    }
                    break;
            }
        }

        // --- Thumbnail Holo Effect Logic ---
        function applyHoloListeners(containerSelector) {
            const container = document.querySelector(containerSelector);
            if (!container) return;
            container.addEventListener('pointermove', handleHoloMove);
            container.addEventListener('pointerleave', handleHoloEnd);
        }
        
        function handleHoloMove(e) {
            if (e.pointerType === 'touch') return;
            const target = e.target.closest('.thumbnail');
            if (!target || !target.classList.contains('in-view') || 
                target.classList.contains('holo-click-active') || 
                target.querySelector('.bg-gray-600')) {
                return;
            }
            
            const rect = target.getBoundingClientRect(); 
            const clientX = e.clientX;
            const clientY = e.clientY;
            
            const offsetX = clientX - rect.left; 
            const offsetY = clientY - rect.top;
            const w = target.offsetWidth; 
            const h = target.offsetHeight;
            
            if (w === 0 || h === 0) return;
            
            const px = Math.abs(Math.floor(100 / w * offsetX) - 100); 
            const py = Math.abs(Math.floor(100 / h * offsetY) - 100);
            const pa = (50 - px) + (50 - py);
            const lp = (50 + (px - 50) / 1.5); 
            const tp = (50 + (py - 50) / 1.5);
            const px_spark = (50 + (px - 50) / 7); 
            const py_spark = (50 + (py - 50) / 7);
            const p_opc = Math.min(Math.max(20 + (Math.abs(pa) * 1.5), 20), 90);
            
            target.classList.add('holo-active');
            target.style.setProperty('--thumb-gradient-pos-x', `${lp}%`); 
            target.style.setProperty('--thumb-gradient-pos-y', `${tp}%`);
            target.style.setProperty('--thumb-sparkle-pos-x', `${px_spark}%`); 
            target.style.setProperty('--thumb-sparkle-pos-y', `${py_spark}%`);
            target.style.setProperty('--thumb-sparkle-opacity', p_opc / 100);
            
            clearTimeout(activeHoloTimeout);
        }
        
        function handleHoloEnd(e) {
            const target = e.target.closest('.thumbnail');
            if (target && target.classList.contains('in-view') && 
                target.classList.contains('holo-active') && 
                !target.classList.contains('holo-click-active')) {
                
                activeHoloTimeout = setTimeout(() => { 
                    resetHoloEffect(target); 
                }, 50);
            }
        }
        
        function resetHoloEffect(element, resetTransform = true) {
            if (!element) return;
            
            element.classList.remove('holo-active');
            if (resetTransform && !element.classList.contains('holo-click-active')) { 
                element.style.transform = 'scale(1)'; 
            }
            element.style.removeProperty('--thumb-gradient-pos-x'); 
            element.style.removeProperty('--thumb-gradient-pos-y');
            element.style.removeProperty('--thumb-sparkle-pos-x'); 
            element.style.removeProperty('--thumb-sparkle-pos-y');
            element.style.removeProperty('--thumb-sparkle-opacity');
        }
        
        // --- Fancy Lightbox Holo Effect Logic ---
        function applyFancyHoloListeners(containerSelector) {
            const container = document.querySelector(containerSelector);
            if (!container) return;
            container.addEventListener('pointermove', handleFancyHoloMove);
            container.addEventListener('pointerleave', handleFancyHoloEnd);
        }
        
        function handleFancyHoloMove(e) {
            if (e.pointerType === 'touch' || isZoomed) return;
            
            const container = fancyHoloContainer;
            const target = fancyHoloInner;
            if (!container || !target) return;
            
            const rect = container.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            // Calculate relative position within container
            const relativeX = clientX - rect.left;
            const relativeY = clientY - rect.top;
            
            // Calculate percentage position (0-100) for both axes
            const percentX = (relativeX / rect.width) * 100;
            const percentY = (relativeY / rect.height) * 100;
            
            // Calculate rotation degrees based on mouse position
            // Map from 0-100% to -20 to 20 degrees for subtle effect
            const rotateY = ((percentX / 100) - 0.5) * 20;
            const rotateX = (((percentY / 100) - 0.5) * -20);
            
            // Calculate normalized values for effects
            const normX = percentX / 100;
            const normY = percentY / 100;
            
            // Calculate gradient positions (shift slightly from mouse)
            const gradientX = 50 + ((percentX - 50) / 1.5);
            const gradientY = 50 + ((percentY - 50) / 1.5);
            
            // Calculate sparkle effect positions (subtler movement)
            const sparkleX = 50 + ((percentX - 50) / 5);
            const sparkleY = 50 + ((percentY - 50) / 5);
            
            // Calculate opacity based on distance from center (more intense at edges)
            const distFromCenter = Math.sqrt(Math.pow((normX - 0.5) * 2, 2) + Math.pow((normY - 0.5) * 2, 2));
            const sparkleOpacity = Math.min(0.3 + distFromCenter * 0.7, 0.9);
            
            // Apply the effects
            target.classList.add('holo-active');
            target.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            
            // Set CSS variables for gradient and sparkle effect positions
            target.style.setProperty('--lb-gradient-pos-x', `${gradientX}%`);
            target.style.setProperty('--lb-gradient-pos-y', `${gradientY}%`);
            target.style.setProperty('--lb-sparkle-pos-x', `${sparkleX}%`);
            target.style.setProperty('--lb-sparkle-pos-y', `${sparkleY}%`);
            target.style.setProperty('--lb-sparkle-opacity', sparkleOpacity);
            
            clearTimeout(fancyActiveHoloTimeout);
        }
        
        function handleFancyHoloEnd(e) {
            if (isZoomed) return;
            
            const target = fancyHoloInner;
            if (!target) return;
            
            const relatedTarget = e.relatedTarget;
            if (relatedTarget && fancyHoloContainer.contains(relatedTarget)) {
                return; // Still within container, don't reset
            }
            
            fancyActiveHoloTimeout = setTimeout(() => resetFancyHoloEffect(), 50);
        }
        
        function resetFancyHoloEffect() {
            const target = fancyHoloInner;
            if (!target) return;
            
            target.classList.remove('holo-active');
            
            // Only reset transform if not zoomed
            if (!isZoomed) {
                target.style.transform = '';
            }
            
            // Remove CSS variables
            target.style.removeProperty('--lb-gradient-pos-x');
            target.style.removeProperty('--lb-gradient-pos-y');
            target.style.removeProperty('--lb-sparkle-pos-x');
            target.style.removeProperty('--lb-sparkle-pos-y');
            target.style.removeProperty('--lb-sparkle-opacity');
        }

        // --- Helper Functions for Color Manipulation ---
        function hexToRgba(hex, alpha = 1) {
            hex = hex.replace('#', '');
            if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            const bigint = parseInt(hex, 16);
            if (isNaN(bigint)) return `rgba(107, 114, 128, ${alpha})`;
            const r = (bigint >> 16) & 255; 
            const g = (bigint >> 8) & 255; 
            const b = bigint & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function lightenHexColor(hex, percent) {
            hex = hex.replace('#', '');
            if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            const num = parseInt(hex, 16); 
            if (isNaN(num)) return '#FFFFFF';
            const amt = Math.max(-255, Math.min(255, Math.round(2.55 * percent * 100)));
            let r = (num >> 16) + amt; 
            let g = ((num >> 8) & 0x00FF) + amt; 
            let b = (num & 0x0000FF) + amt;
            r = Math.max(0, Math.min(255, r)); 
            g = Math.max(0, Math.min(255, g)); 
            b = Math.max(0, Math.min(255, b));
            const originalLuminance = (0.2126*((num>>16)/255) + 0.7152*(((num>>8)&0x00FF)/255) + 0.0722*((num&0x0000FF)/255));
            if (originalLuminance < 0.4 && percent > 0) { 
                const minLightness = 180; 
                r=Math.max(r,minLightness); 
                g=Math.max(g,minLightness); 
                b=Math.max(b,minLightness);
            }
            return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
        }

        /** Applies the selected gallery size class */
        function applyGallerySize(sizeIndex) {
            if (!itemGallery || sizeIndex === undefined || sizeIndex === null) return;
            const validIndex = Math.max(0, Math.min(sizeIndex, Object.keys(GALLERY_SIZE_CLASSES).length - 1));
            Object.values(GALLERY_SIZE_CLASSES).forEach(cls => itemGallery.classList.remove(cls));
            itemGallery.classList.add(GALLERY_SIZE_CLASSES[validIndex]);
            console.log(`[applyGallerySize] Applied class: ${GALLERY_SIZE_CLASSES[validIndex]}`);
            if (gallerySizeDisplay) gallerySizeDisplay.textContent = SIZE_MAP[validIndex] || SIZE_MAP[DEFAULT_GALLERY_SIZE_INDEX];
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("[Init] DOM Loaded. Checking for imageData...");
            
            // Set up intersection observer for lazy loading
            setupIntersectionObserver();
            
            // First check for data loaded from image_data.js
            if (typeof imageData === 'undefined' || typeof imageData.imageStructure !== 'object' || typeof imageData.filterConfig !== 'object') {
                console.error("[Init] ERROR: 'imageData' object (with .imageStructure and .filterConfig) is missing or invalid in image_data.js.");
                displayError(`Configuration Error! Please ensure 'image_data.js' is generated correctly with the variable name 'imageData' containing 'imageStructure' and 'filterConfig' keys.`);
                [typeFilterSelect, forteFilterSelect, trainerTypeFilterSelect, creatorFilterSelect, gallerySizeSlider].forEach(el => el && (el.disabled = true));
                
                // Hide loading overlay even on error
                if (pageLoadingOverlay) {
                    pageLoadingOverlay.classList.add('loaded');
                }
                
                return;
            }
            
            console.log("[Init] imageData found:", imageData);
            rootImageStructure = imageData.imageStructure;
            filterConfig = imageData.filterConfig;

            // Validate further
            if (!rootImageStructure || !rootImageStructure.path || !filterConfig.setOrder) {
                console.error("[Init] ERROR: Loaded data structure or config is incomplete.");
                displayError(`Configuration Error! Data loaded from image_data.js is incomplete.`);
                [typeFilterSelect, forteFilterSelect, trainerTypeFilterSelect, creatorFilterSelect, gallerySizeSlider].forEach(el => el && (el.disabled = true));
                
                // Hide loading overlay even on error
                if (pageLoadingOverlay) {
                    pageLoadingOverlay.classList.add('loaded');
                }
                
                return;
            }

            baseImageSet = getAllImageFilesRecursive(rootImageStructure);
            populateFilters();
            renderTabs();

            // --- Size Slider Initialization ---
            const savedGallerySize = localStorage.getItem(GALLERY_SIZE_KEY) || DEFAULT_GALLERY_SIZE_INDEX.toString();
            gallerySizeSlider.value = savedGallerySize; 
            applyGallerySize(parseInt(savedGallerySize));

            // --- Size Slider Event Listeners ---
            gallerySizeSlider.addEventListener('input', (e) => { 
                const v = parseInt(e.target.value); 
                applyGallerySize(v); 
                localStorage.setItem(GALLERY_SIZE_KEY, v.toString()); 
            });

            // Initial Render based on 'All' tab (excluding MISC)
            baseImageSet = getAllImageFilesRecursive(rootImageStructure).filter(img => img.setName !== "Misc");
            console.log("[Init] Initial base image set size (excluding MISC):", baseImageSet.length);
            applyFiltersAndRender();

            // --- Event Listeners ---
            // Filter dropdowns
            typeFilterSelect.addEventListener('change', (e) => { 
                currentTypeFilter = e.target.value; 
                applyFiltersAndRender(); 
            });
            
            forteFilterSelect.addEventListener('change', (e) => { 
                currentForteFilter = e.target.value; 
                applyFiltersAndRender(); 
            });
            
            trainerTypeFilterSelect.addEventListener('change', (e) => { 
                currentTrainerTypeFilter = e.target.value; 
                applyFiltersAndRender(); 
            });
            
            creatorFilterSelect.addEventListener('change', (e) => { 
                currentCreatorFilter = e.target.value; 
                applyFiltersAndRender(); 
            });
            
            // Fancy lightbox controls
            fancyLightboxClose.addEventListener('click', closeFancyLightbox);
            fancyPrevButton.addEventListener('click', showPreviousCard);
            fancyNextButton.addEventListener('click', showNextCard);
            fancyNormalView.addEventListener('click', () => switchCardView('normal'));
            fancyTextlessView.addEventListener('click', () => switchCardView('textless'));
            fancyZoomIn.addEventListener('click', zoomIn);
            fancyZoomOut.addEventListener('click', zoomOut);
            fancyZoomReset.addEventListener('click', resetZoom);
            
            // Dragging interactions for card
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let rotateX = 0;
            let rotateY = 0;
            
            fancyHoloContainer.addEventListener('mousedown', (e) => {
                if (isZoomed) return;
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                fancyHoloContainer.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;
                
                // Scale the rotation (smaller values for subtler effect)
                rotateY = deltaX * 0.1;
                rotateX = -deltaY * 0.1;
                
                // Apply rotation directly
                fancyHoloInner.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    fancyHoloContainer.style.cursor = 'grab';
                    
                    // Smoothly reset to center if not zoomed
                    if (!isZoomed) {
                        fancyHoloInner.style.transition = 'transform 0.5s ease-out';
                        fancyHoloInner.style.transform = '';
                        setTimeout(() => {
                            fancyHoloInner.style.transition = '';
                        }, 500);
                    }
                }
            });
            
            // Double-click to zoom
            fancyHoloContainer.addEventListener('dblclick', () => {
                if (isZoomed) {
                    resetZoom();
                } else {
                    zoomIn();
                }
            });
            
            // Keydown listeners for gallery and lightbox
            document.addEventListener('keydown', (e) => {
                if (fancyLightbox.classList.contains('visible')) {
                    handleFancyLightboxKeyDown(e);
                } else {
                    // Only handle gallery keys if focus is in the gallery
                    if (document.activeElement && (itemGallery.contains(document.activeElement) || 
                                                 tabContainer.contains(document.activeElement))) {
                        handleGalleryKeyDown(e);
                    }
                }
            });
            
            // Apply holo effects
            applyHoloListeners('#item-gallery');
            
            // Hide loading overlay when everything is ready
            if (pageLoadingOverlay) {
                setTimeout(() => {
                    pageLoadingOverlay.classList.add('loaded');
                }, 500); // Short delay for smoother transition
            }
            
            // Trigger lazy loading for initial viewport
            if (intersectionObserver) {
                const initialThumbnails = itemGallery.querySelectorAll('.thumbnail');
                initialThumbnails.forEach(thumbnail => {
                    if (isElementInViewport(thumbnail)) {
                        thumbnail.classList.add('in-view');
                        const img = thumbnail.querySelector('img');
                        if (img && img.dataset.src) {
                            img.src = img.dataset.src;
                            delete img.dataset.src;
                        }
                    }
                });
            }
        });
        
        /** Check if element is in viewport */
        function isElementInViewport(el) {
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= -100 &&
                rect.left >= -100 &&
                rect.bottom <= (window.innerHeight + 100) &&
                rect.right <= (window.innerWidth + 100)
            );
        }
    </script>
</body>
</html>